<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[暂停github博客更新说明]]></title>
      <url>%2F2018%2F06%2F07%2F%E6%9A%82%E5%81%9Cgithub%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E.html</url>
      <content type="text"><![CDATA[暂停更新github博客，会更新在issues内和掘金中。 写博客的核心目的是复盘总结分享，Hexo是折腾尝试阶段的产物，更好的方式也许是在issues中做随记，在掘金中输出分享出来的内容凌乱且不成体系，需要聚焦持续强化 菜鸟时期 ntscshen.github.io仓库issues随记 juejin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阮老师的未来世界的幸存者读后记]]></title>
      <url>%2F2018%2F02%2F01%2F%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85%E8%AF%BB%E5%90%8E%E8%AE%B0.html</url>
      <content type="text"><![CDATA[现实 未来经济增长将持续放缓,几乎所有行业都不会有以前那么高的增长率,除了高科技行业长期来看,一定是技术主导,中短期是权利和经济导向 职业 如果一个新人接手你的岗位,他能否再几个月内快速上手,而它们要求的报酬又是多少?每年都应该更新和夯实自己的知识体系( 清理过时的体系,加入当下需要的,未来需要的 )B计划( 应急预案 )：不以回报为目的的计划?B计划当成逃离A计划的一个机会。 方法 学技术要掌握：本质的、底层的,本质的东西搞明白,会給我们带来”莫大的帮助“,本质性、结构性的东西属于基础建设方面的问题，它对我们做项目可能不会带来直接的帮助，但在无形中会带来很大的影响，·无形的通常是最宝贵的！“撑一下海阔天空”，一试再试做不成，再试一下，再试一下。把工作当成自己的事情去做 未来尤可知保持终身学习,永不不要懈怠]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是？事件轮询和异步I/O]]></title>
      <url>%2F2018%2F02%2F01%2F%E4%BB%80%E4%B9%88%E6%98%AF%EF%BC%9F%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E5%92%8C%E5%BC%82%E6%AD%A5I-O.html</url>
      <content type="text"><![CDATA[什么是？事件轮询和异步I/O 事件驱动(事件轮询) 和 非阻塞的I/O处理(异步I/O),这些概念该如何理解? 浏览器,Node.js,JavaScript语言,说的是一个东西吗? 它们直接有什么关系? 浏览器真的是单线程吗? 既然是单线程可为什么：页面渲染和Ajax请求时并行的? 同步和异步 同步：是程序发出调用的时候,一直等待直到返回结果,没有结果之前不会返回。也就是,同步是调用者主动等待调用的过程异步：是程序发出调用之后,马上返回,但不会马上返回结果。调用者不必主动等待,当被调用者得到结果之后,会主动通知调用者 阻塞和非阻塞 阻塞(Blocking)：调用在等待的过程中,线程被”挂起”( CPU资源被分配到其他地方 )非阻塞( Non-blocking )：调用在等待的过程中,CPU资源还在该线程中,线程还可以做其他事情 进程和线程 进程(Process)：是系统资源分配和调度的单元。一个运行的程序就对应一个进程。一个进程包括了运行中的程序和程序所使用到的内存和系统资源线程(Thread)：是进程下的执行者,一个进程至少会开启一个线程(主线程),也可以开启多个线程。 总结一下这些概念性的东西 只需要大概知道我们”通常所说的同步都是阻塞的“,主线程调用一个API时,要等待他的结果后才能往下执行异步：”通常所说的是非阻塞的异步“ 单线程的JavaScript(JavaScript运行环境的单线程) JavaScript最大的特点是单线程,这就意味着,同一时间内只能做一件事。JavaScript的单线程设计,与它的用途有关,作为”浏览器脚本语言“,JavaScript的主要用于与用户互动和操作DOM。主要应用场景决定了其只能是单线程,否则会带来很复杂的同步问题。e.g：假定JavaScript同时有两个进程,一个进程在某个DOM节点上添加内容,另一个线程删除了这个节点,此时浏览器应该以哪个线程为准? 为了避开这种并行处理的复杂情况,设计者们没有給这门脚本语言多线程的能力 我们说的单线程,主要指的是什么? 说到JS单线程还是多线程,得结合具体运行环境。JS通常运行在浏览器中,具体由JS引擎去解析和运行,这里说的JS单线程主要是：JS的业务代码在单线程中执行(JS引擎)仅仅指的是,JS在执行的过程中是单线程的。但是,一个页面在浏览器中工作,实际上浏览器不止使用一个线程来运行它的任务( e.g：浏览器提供的WebAPI - XMLHttpRequest,SetTimeout,Promise等等 ),还是利用了多线程和操作系统的任务调度。 浏览器中的线程JavaScript是单线程的Node.js是单线程的非阻塞IO但实际上”浏览器“的内核是多线程的,因为浏览器除了执行JS代码,还有很多事情要做。例如：处理用户DOM事件,处理Timer,所以一个浏览器通常由以下几个常驻的线程： 渲染引擎线程：负责渲染页面 JS引擎线程：负责JS的解析和执行( 常说的JS是单线程,指的是解析和执行的过程 ) 定时器线程：处理定时器(setTimeout,setInterval) 事件触发线程：处理DOM事件 异步Http请求线程：处理http请求如果没有这些线程的存在,可能一句setTimeout(fn, 10000) 就导致主线程的卡死JS引擎可以说是JS虚拟机,负责JS代码的解析和执行,通常包括以下几个步骤 词法分析：将源代码分解成有意义的分词 语法分析：用语法分析器将分词解析成语法树 代码生成：生成机器能运行的代码 代码执行…需要注意的是：渲染线程和JS引擎线程：是不能同时进行的 渲染线程在执行任务的时候,JS引擎线程会被挂起。因为JS可以操作DOM,若在渲染的过程中JS又处理了DOM,浏览器可能就不知所措了这也解释了”为什么不能把script标签放在html头部”,因为JavaScript执行会阻塞渲染线程的渲染,他俩是相互阻塞的。 Node.js中的线程机制 《Node.js实战》书中有一句怎么说的：Node为服务端JavaScript提供了一个事件驱动的、异步的平台。它把JavaScript带到服务器中的方式跟浏览器把JavaScript带到客户端的方式几乎一模一样。Node.js如何通过单线程来实现高并发和异步I/O?Node.js本身是一个多线平台,而它对JavaScript层面的任务处理是单线程的。因为其本身的单线程特性,通过事件驱动模型实现了高并发和异步I/O,本身只有一个主线程来接受请求,但它接受请求以后没有直接做处理,而是放到了事件队列中,让后又去接受其他请求,空闲时候,再通过Event Loop来处理这些事件,从而实现了异步效果。当然对于I/O类任务还需要依赖系统层面的线程池来处理。Node优势在于：处理高并发和异步I/ONode劣势在于：CUP密集型(对数据进行加解密,数据压缩和解压),如果前面CPU计算任务没有完成,后面的任务就会被阻塞,出现响应缓慢的情况,如果”服务器”本身是单核的就算了,但现在大部分服务器都是多CPU,多核的,而Node.js只有一个EventLoop,也就是只占用一个CPU内核,当Node.js被CPU密集型任务占用,导致其他任务被阻塞,却还有CPU内核处于闲置状态,造成资源浪费。 - 这个问题可以使用 Web Worker模式应对：它允许一段JavaScript程序运行在主线程之外的另一个线程中。大多数网站的服务器端都不会做太多的计算,它们只是接受请求,交给其他服务(文件系统 | 数据库),让后等待结果返回,再发给客户端。适用场景： RESTful API：请求和响应只需要少量文本,并不需要大量逻辑处理,一次可以并发处理数以万计的链接 聊天服务：轻量级,高流量,没有复杂的技术逻辑，是构建运行在分布式设备上的数据密集型实时程序完美选择。 业务不复杂的情况,节约服务器经费,轻量,高效。浅析 Node.js 单线程模型Node.js软肋之CPU密集型任务 单线程和异步IO之间的关系从网页 | Nodejs开发者的角度,JavaScript看起来就是发起异步任务,并且异步任务完成后会自动执行回调。完全可以认为：JavaScript进行的相关开发就是异步非阻塞IO的。一. JavaScript平台(浏览器和Node)是通过另开线程来实现异步IO的Node系统底层的libuv实现单独的线程进行IO,其异步IO又使用真正的内核异步IO API(epoll),而内核通过信号或回调来通知libuv里的IO线程,libuv的IO线程通过事件的方式告知Node.js主线程浏览器内核本身就是多线程的,浏览器处理执行JS代码,还有很多事情需要做。 渲染页面(渲染引擎 - 线程) 执行JS(JS引擎 - 线程) 处理定时器(定时器触发线程 - 线程) 处理DOM事件(事件触发 - 线程) 处理http请求(异步http请求 - 线程)二. 在JavaScript平台上,之所写的异步IO代码可以”被动得执行回调函数“,是由于JavaScript主线程(JS执行引擎)里的EventLoop事件循环线程实现的。JavaScript平台底层libuv收到底层通知后,会給任务装入IO数据,放入被JavaScript主线程轮询的任务/事件队列中,从而JavaScript主线才能轮询到任务进行还在线。在操作系统底层,所谓的异步IO的回调是通过系统給进程发送信号等中断机制来实现的,确实是内核通知或回调进程里的代码来实现了通知。JavaScript这个默认回到机制,是其主线程配合其他线程实现了一套异步的事件机制,表面上看起来是被回调了。 JavaScript平台：老大是主线程(开发商自己\政府关系员\项目经理\设计人员\技术员) - 手里掌握握着一堆资源调取其他线程 - API调取(外包或自己手下的小弟：桩基工\混泥土工\钢筋工\电焊工\塔吊工\起重工\木工...) 在开发的过程中,简单的事情自己解决 开发商干的事情就是,主导整个项目流程(按照顺序依次执行开发)开发一栋大楼：你有想法有钱有地皮有人开搞(万事俱备,只差执行)桩基大楼 - 分包给桩基人员(调取”桩基人员”线程 - 打地基)盖楼1 - 混泥土(调取”混泥人员”土线程 - 基本盘)盖楼2 - 钢筋(调取”钢筋人员”线程 - 基本盘)盖楼3 - 电焊筋(调取”电焊人员”线程 - 基本盘)盖楼4 - 木工(调取”木工”线程 - 基本盘)盖楼5 - 塔吊\起重(调取”塔吊\起重”线程 - 基本盘)盖楼XXX - … 耗时的(ajax,setTimeout,Promise),复杂的,有比自己做更好更快的,找人解决 - 开独立线程去解决找人干活,需要有先前约定,只关注结果不关心过程,做完后去找指定的人(助理 - 任务队列),整理好先后顺序(先入先出),整理好文件放在办公桌上,董事长手里事情做完会,就会去处理这些文件。任务队列：办公室(助理去整理这些事情 - 维护的一个观察队列 - 任务队列)Event Loop：当手上的事情处理完成,就会去读取文件并处理(一直这样,做完事情,就读取文件处理) - 一直轮询只有一个事件循环Event Loop,但是有多个任务队列(callback queue),在浏览器中,总体上看任务队列有两种：macro-task(常常所说的任务队列): script(整体代码),setTimeout,setInterval,setImmediate,I/O,IO renderingmicro-task: process.nextTick, Promise(浏览器原生Promise),object.observe,MutationObserver 比喻的不太恰当啊,以后再修改。。。。比喻的不太恰当啊,以后再修改。。。。比喻的不太恰当啊,以后再修改。。。。 Node.js中的事件循环 Node.js中的事件循环是靠libuv实现的。 事件轮询(Event Loop)不止一个任务队列callback queue 是事件队列在浏览器中,只有一个事件循环,但有两个任务队列(macro task和 micro task)micro task：script(整体代码)、setTimeout、setInterval、setImmediate,I/O,IO renderingmacro task：process.nextTick,Promise(原生),Object.observe,MutationObserver 定时器Node.js的Event LoopJS执行时,主线程就已经跑起EventLoop了。你所写的JS代码只是被运行时的主线程作为某个事件的handler触发运行,你的JS代码并不是整个运行进程的main函数。你的JS对自己所在的主线程根本没有完全的控制能力,你自己写的JS代码,只不过是JS执行线程里的一个会被首次执行的MacroTask任务而已。 参考链接JavaScript 运行机制详解：再谈Event Loop[学习]-浏览器的单线程机制和事件循环这一次，彻底弄懂 JavaScript 执行机制【转向Javascript系列】从setTimeout说事件循环模型深入浅出JavaScript事件循环机制(下)Node.js 探秘：初识单线程的 Node.jsJavaScript单线程异步的背后——事件循环机制浅析 Node.js 单线程模型Node.js软肋之CPU密集型任务Javascript是单线程的深入分析 项目 时间 饥人谷( 面试题 ) 2018年03月19日(周一) - 2018年03月20日(周二) 电话模拟面试( 8个 ) 2018年03月21日(周三) - 2018年03月22日(周四) webpack独立准备( 搭建项目 ) 2018年03月23日(周五) 工作中流程、配合方式svn/wiki/jira等、简历改版、自我介绍 周六、周日 下周一投递简历]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Phaser开发H5小游戏(一)]]></title>
      <url>%2F2017%2F06%2F20%2FPhaser%E5%BC%80%E5%8F%91H5%E5%B0%8F%E6%B8%B8%E6%88%8F(%E4%B8%80).html</url>
      <content type="text"><![CDATA[刚刚学习Phaser、在博客上记载一下学习过程。先从官方的小例子开始😁 需要本地Web服务器。 npm install http-server -g 可以使用它来配置简单的http服务 browser-sync 或 browser-sync-webpack-plugin 或 devServer 下载Phaser.js官网github下载 个人线上地址 再次 需要下载教程内的资源制作第一个小游戏(part1) 创建游戏实例 123456789101112var game = new Phaser.Game(800, 600, Phaser.AUTO, '', &#123; preload: preload, create: create, update: update&#125;);function preload() &#123;&#125;function create() &#123;&#125;function update() &#123;&#125;// 前两个参数是Phaser创建的游戏元素的宽高(您可以设置任何您喜欢的尺寸)// 第三个参数(如何渲染游戏)可以是：Phaser.CANVAS,Phaser.WEBGL或Phaser.AUTO。 推荐参数是Phaser.AUTO, 它会自动尝试使用WebGL,如果浏览器或设备不支持,它将返回到Canvas// 第四个参数, 创建的游戏元素需要插入的DOM元素的ID。 这个参数设置为空,它将会被依附到body身上。// 最后的参数, 是Phaser基本功能的对象引用(不是必须的)、对于一个简单入门小游戏、使用这种方式、因为它方便快捷 制作第一个小游戏(part2)12345678910111213function preload() &#123; game.load.image('sky', 'assets/sky.png'); game.load.image('ground', 'assets/platform.png'); game.load.image('star', 'assets/star.png'); game.load.spritesheet('dude', 'assets/dude.png', 32, 48);&#125;// preload 预加载// 加载需要的文件资源、通过game.add来执行这个操作// 代码中加载了、三个图片和一个精灵图。第一个参数 - 称之为资产秘钥。此秘钥指向已加载资源的链接、可以在任何位置使用function create() &#123; game.add.sprite(0, 0, 'star');&#125;// 在游戏场景中添加一个精灵 制作第一个小游戏(part3)123456789101112131415161718192021222324// 构建背景var platforms;// 平台function create() &#123; // 为游戏添加物理引擎 - Arcade(实现简单的碰撞、重力等效果最佳。适合移动浏览器) game.physics.startSystem(Phaser.Physics.ARCADE); // 添加填空背景 game.add.sprite(0, 0, 'sky'); // 平台组：包含地面和两个支撑平台 platforms = game.add.group(); // 在platforms组中创建的对象 - 启用物理引擎 platforms.enableBody = true; // 创建地面 var ground = platforms.create(0, game.world.height - 64, 'ground'); // 缩放地面长度 - 以适应游戏大小 ground.scale.setTo(2, 2); // 当你跳上去的时候、他会阻止当前平台掉下来 ground.body.immovable = true;// immovable: 不可动摇的 // 创建两个平台 var ledge = platforms.create(400, 400, 'ground'); ledge.body.immovable = true; ledge = platforms.create(-150, 250, 'ground'); ledge.body.immovable = true;&#125;// 如果不设置 ledge.body.immovable = true; 当玩家于其碰撞时,地面会跟随其移动 制作第一个小游戏(part4) 准备游戏人物 123456789player = game.add.sprite(32, game.world.height - 150, 'dude');game.physics.arcade.enable(player);// 为精灵启动物理引擎、在组中启动物理引擎是 platforms.enableBody = true;player.body.bounce.y = 0.2;// bounce:弹跳。給玩家轻微反弹player.body.gravity.y = 300;// gravity:重力。这个值越高、物体感觉越重、下降越快player.body.collideWorldBounds = true;// 超出世界的界限、将会碰撞回来// Phaser独有的序列帧动画player.animations.add('left', [0, 1, 2, 3], 10, true);player.animations.add('right', [5, 6, 7, 8], 10, true); 总共有9帧。面相用户的是第4个，左边4个、右边4个。定义了两个动画’left’、’right’ true参数告诉Phaser动画是循环播放的。’10’ 为毫秒的时间。10毫秒执行一次动画帧 制作第一个小游戏(part5) 打开part5.html (请开启服务) 你会发现游戏玩家、完全无视地面的存在。这是由于我们还没有添加地面和玩家之间的碰撞。 之前我们的代码只是创建地面并且告诉Phaser地面和平台都是不可以移动的( ground.body.immovable = true; ) 因此我们需要在update中添加碰撞检测 12345function update() &#123; var hitPlatform = game.physics.arcade.collide(player, platforms);&#125;// hit 碰撞 platform 平台// collide(游戏人物, 平台); update参数添加完成后 - 如果注释了create() 中的 ground.body.immovable = true; 在去看看实际效果 制作第一个小游戏(part6) 用键盘控制游戏人物 玩家需要根据键盘的方向去移动。 Phaser有一个内置的键盘管理器 cursors = game.input.keyboard.createCursorKeys(); 123456789101112131415161718192021222324function create() &#123; ... cursors = game.input.keyborad.createCursorKeys();&#125;function update() &#123; // 玩家和平台碰撞 game.physics.arcade.collide(player, platforms); // 重置玩家 - 速度(velocity) player.body.velocity.x = 0; if(cursors.left.isDown)&#123;// 键盘左 player.body.velocity.x = -150; player.animations.play('left');// 序列帧动画执行left &#125;else if(cursors.right.isDown)&#123; player.body.velocity.x = 150; player.animations.play('right'); &#125;else&#123;// 左右键不触发 - 则停止序列帧动画 - 显示第四帧 player.animations.stop(); player.frame = 4; &#125; if(cursors.up.isDown &amp;&amp; player.body.touching.down)&#123;// 玩家接触地面 player.body.velocity.y = -200; &#125; // player.body.touching.down 如果不设置这段、则游戏会出现Bug。玩家在半空中跳跃&#125; 制作第一个小游戏(part7) 前面6个part已经完成了主体部分 part7来添加一些星星✨、让玩家收集它们。辣么多的星星、需要添加星星组。 12345678910111213141516171819202122232425function create() &#123; ... // 创建星星组 starts = game.add.group(); // 为组内的创建的元素、启动物理引擎 starts.enableBody = true; // 均匀创建12个隔断 for(var i = 0;i &lt; 12; i++)&#123; var star = stars.create(i*70, 0, 'star'); star.body.gravity.y = 300; // 随机添加弹跳系数 star.body.bounce.y = 0.7 + Math.random() * 0.2; &#125;&#125;function update() &#123; // 人物和地面 碰撞 game.physics.arcade.collide(player, platforms); // 星星和地面 碰撞 game.physics.arcade.collide(stars, platforms); // 检测玩家是否和星星碰撞、如果碰撞则调用collectStar函数 game.physics.arcade.overlap(player, stars, collectStar, null, this) function collectStar(player, star) &#123; star,kill();// 杀死星星 &#125;&#125; 制作第一个小游戏(part8) 最后完善 添加分数 12345678910111213141516171819var score = 0;var scoreText;...function create() &#123; scoreText = game.add.text(16, 16, 'Score:0', &#123; fontSize: '32px', fill: '#000' &#125;);&#125;function update() &#123; ... function collectStar(player, star) &#123; star,kill(); // 添加更新的分数 score += 10; scoreText.text = 'Score: ' + score; // 跟新具体的变量、需要获取对应的值进行改变... &#125;&#125; 总结 官方的第一个游戏用例、里面的知识都非常、非常的基础和重要。 基础的生命周期概念(create、update、play、over) 物理引擎 Arcade game.add.group()组的概念 Phaser内置的键盘 序列正动画 物理引擎 Arcade game.physics.startSystem(Phaser.Physics.ARCADE) 为游戏启动Arcade引擎 game.physics.arcade.enable(player); // 为指定的元素添加引擎 game.physics.enable(player, Phaser.Physics.ARCADE); 这两个意思是相等的 platforms.enableBody = true; 将为组中创建的任何对象 - 启动物理引擎 ground.body.immovable = true 为当前元素添加了immovable之后、相当于一个地面平台。不会随着其他重力物体的碰撞而随之改变位置。( 我心如铁、坚不可摧😀 ) player.body.bounce.y = 0.2 弹跳系数。 TODO：随机弹跳系数 player.body.bounce.y = 0.2 + Math.random() * 0.2 player.body.gravity.y = 300; 重力系数 player.body.collideWorldBounds = true; 超出游戏世界范围、将会被弹回来 game.add.group()组的概念 将类似的对象组合在一起、并将其全部控制为一个单独的单元体。 组和组可以进行碰撞、组合精灵可碰撞。但是组合图片无法碰撞 在组中创建元素 stars = game.add.group(); stars.create(0, 0, &#39;star&#39;); stars.enableBody = true 为组中创建的任何对象 - 启动物理引擎 image 无法实现逐帧动画、无法添加物理属性 Phaser内置的键盘 game.input.keyboard.createCursorKeys(); keyboard：监视键盘输入和调度键盘事件。 createCursorKeys()：创建并返回一个包含上、下、左、右4个热键的对象 事件的触发需要在update中执行 序列帧动画 首先序列帧动画 game.load.spritesheet(&#39;xxx&#39;,&#39;xxx.png&#39;,32,32); 必须使用 spritesheet加载 而且后面的参数是一个序列帧的宽高。必须的(如果你想使用序列帧动画的话) 12345678// 1、资源加载 - preloadgame.load.spritesheet('dude','xxx.png',32,32);// 2、创建元素 - createvar player = game.add.sprite(32, game.width.height, 'dude');// 3、添加序列动画player.animations.add('sky');player.animations.play('sky', 10, true);// 这个'sky'，相当于资源加载力的key值。 一个正常的序列帧动画、一套动作、执行时间的长短、是否循环。本质的动作下来是一套gif动画的话、可以像上面怎么写↑↑ 如果类似于Phaser官网的第一个小游戏那样话( 在特定的条件下、执行这段动画的特定区域 ) 12345678910111213var player;// 1、资源加载 - preloadgame.load.spritesheet('dude','xxx.png',32,32);// 2、创建元素 - createplayer = game.add.sprite(32, game.width.height, 'dude');player.animations.add('left',[0,1,2,3],20,true);player.animations.add('right',[5,6,7,8],20,true);// 3、更新 - updateif(xxx)&#123; player.animations.play('left');&#125;else&#123; player.animations.play('right');&#125; Phaser中文教程传送门 脑壳痛：现在是知其然 而不 知其所以然 哎、期望不辜负这大好时光~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Phaser开发H5小游戏]]></title>
      <url>%2F2017%2F06%2F01%2F%E4%BD%BF%E7%94%A8Phaser-js%E5%BC%80%E5%8F%91%E5%B0%8F%E6%B8%B8%E6%88%8F.html</url>
      <content type="text"><![CDATA[Phaser Phaser一款HTML5游戏框架,旨在帮助开发人员快速制作出强大的跨浏览器的HTML5游戏、与其他游戏框架不同的是,Phaser已经完成了与移动浏览器的融合、唯一的要求就是支持 Canvas 游戏相关的概念场景 一个完整的游戏分场景(整个游戏的生命周期)： 加载：进度条、加载游戏资源 开始：开始按钮 游戏：游戏中、主体逻辑 结束：得分、排名 对象池 游戏中生成非常多的元素，我们需要一个对象池来维护他们。 尽可能的复用对象，可以减少内存的开销。例如已经移除可视区的对象，重新设置他们的位置，而不是重新创建 如果有确定要销毁的对象，记得显示调用 distroy 方法( 一般的游戏框架不会被销毁killed的对象，他们还可能被”复活” ) 正式开始(一)创建实例12345678910111213var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', &#123; preload: preload, create: create, update: update&#125;);// 话说是每个场景的本体的生命周期。function preload()&#123;&#125;function create()&#123;&#125;function update()&#123;&#125;// 前两个参数对应画布宽高// 第三个参数可以是：Phaser.CANVAS, Phaser.WEBGL, Phaser.AUTO 推荐使用Phaser.AUTO 它会自动尝试使用WebGL, 如果浏览器不支持它,它将使用Canvas// 第四个参数：插入Phaser创建的Canvas元素的DOM节点的ID、如果留空,则会依附到body上// 最终的参数：包含Phasers基本功能的的引用，他们不是必须的。 定义场景 定义每个场景的内容 将创建添加到游戏实例中 game.state.add 12345678910var states = &#123; preload: function()&#123;&#125;,// 加载场景 created: function()&#123;&#125;,// 开始场景 play: function()&#123;&#125;,// 游戏场景 over: function()&#123;&#125;// 结束场景&#125;;Object.keys(states).forEach(function(key)&#123; game.state.add(key,states[key])&#125;);// Object.keys() 返回的是一个对象属性数组 场景串通 具体定义每个场景的生命周期 从一个场景切换到另一个场景 启动游戏 每个场景都有自己的生命周期 preload(加载)： 尽管有预加载场景,如果你希望能缩短进入页面时加载的时间,可以分摊一些到其他场景,只需要在其他场景加入 preload 方法即可 create(创建)： 如果存在preload方法,则会在加载完毕后执行此方法；否则将在进入该场景时直接执行此方法 update(更新)： 跟新周期自动执行的方法 render(渲染完成)： 渲染完毕后执行的方法 12345678910111213141516171819202122232425262728// 独立的应用场景var states = &#123; // 预加载 preload: function()&#123; this.create = function()&#123; game.stage.backgroundColor = '#000';// 设置背景色 game.add.text(32, 32, '内容信息...', &#123;// 设置字体内容 fontSize: '32px', fill: '#efe0ce' &#125;); setTimeout(function()&#123; game.state.start('created');// 3S后切换到开始场景 &#125;,3000); &#125; &#125;, // 创建完毕后的开始按钮场景 created: function()&#123;&#125;, // 主流程：游戏场景 play: function()&#123;&#125;, // 结束 over: function()&#123;&#125;&#125;;// 将对于的场景、添加到游戏中Object.keys(states).forEach(key)&#123; game.state.add(key, states[key])&#125;;// 启动游戏game.state.start('preload'); 正式开始(二) 资源加载物理 开启Arcade物理系统 game.physics.startSystem(Phaser.Physics.ARCADE); 添加组 platforms = game.add.group(); platforms.enableBody = true; 为组中的任何对象启动物理引擎 ground1 = platforms.create(window.innerWidth - 600, 400, &#39;ground&#39;); 在组中添加内容 ground3.scale.setTo(3.5, 3); 缩放以适应游戏大小 game.physics.arcade.enable(player); 启用物理引擎 player.body.collideworldBounds = true; 如果这是真实的，一个物体可以被设置为与世界范围的碰撞和反弹回这个世界。否则它会离开这个世界。 player.animations.add(&#39;left&#39;,[0,1,2,3],10,true) 序列帧动画、在update中使用 player.animations.play(&#39;left&#39;) 启动 碰撞检测必加在update中 game.physics.arcade.collide(player, platforms) 1、按钮]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6数组的扩展]]></title>
      <url>%2F2017%2F05%2F05%2FES6%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html</url>
      <content type="text"><![CDATA[Array.from()Array.from被设计的初衷就是快速便捷的基于其他对象创建新数组 MDN： 从一个类数组或可迭代的对象中创建一个新的数组实例 人话： 只要对象是”类数组” 或 有迭代器( 能够被遍历 ), Array.from 就能把它变成一个数组( 返回新数组,不改变原对象 ) 语法: Array.from(arrayLike,[, mapFn[, thisArg]])` arrayLike ( 必选 ): 类数组对象 mapFn ( 可选 ): 加工函数,新生成的数组会经过该函数的加工在返回 thisArg ( 可选 ): 执行mapFn函数时的this值 返回值：一个新的Array实例 类数组对象 ( 拥有一个length属性和若干索引属性的任意对象 ) 可遍历对象 ( 你可以从它身上迭代出若干个元素的对象 ) 拥有迭代器的对象: obj对象、String、arguments、Set、Map等 注：可选参数 mapFn ,让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说 Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg) 。 我们来看看具体的用法 1234567891011121314151617181920212223242526272829303132// StringArray.from('foo');// ["f", "o", "o"]// NodeList对象let oP = document.querySelectorAll('p');Array.from(oP).forEach(function(el)&#123; console.log(el);&#125;);// arguments: 天生的类数组对象function foo()&#123; return Array.from(arguments);&#125;foo(1,2,3);// [1, 2, 3]// 类数组let obj = &#123; "0": "a", "1": "b", "2": "c", length: 3&#125;;console.log(obj);console.log('转换前的数据类型：' + Object.prototype.toString.call(obj));let ary = Array.from(obj);console.log(ary);console.log('转换后的数据类型：' + Object.prototype.toString.call(ary));Array.from(obj, function(value, index)&#123; console.log(value, index, this, arguments.length); return value * index; // 必须指定返回值,否则返回undefined&#125;, obj);// 如果不用指定this,mapFn完全可以使用箭头函数代替Array.from(obj, (value, index) =&gt; console.log(value, index)); 扩展一个重要的场景,比如生成一个从0到指定数字的新数组,Array.from可以轻易做到 1234Array.from(&#123;length: 10&#125;, function(value, index)&#123; return index;&#125;)// Array.from(&#123;length: 10&#125;, (value, index) =&gt; index); Chrome Firefox(Gecko) Edge IE Opera Safari 45 32 Yes 未实现 Yes 9.0 如需更好的支持低版本浏览器,请参考 polyfill Array.isArray 用来判断一个变量是否数组类型 Array方法 数组原型提供的方法非常多,主要分成三种： 一种会改变自身值( 9 ) 一种不会改变自身( 9 ) 一种是遍历方法( 12 ) 1Object.getOwnPropertyNames(Array.prototype);// 获取Array.prototype上的所有方法 遍历方法forEach、every、some、filter、map、reduce、reduceRight ES6新增：entries、find、findIndex、keys、values forEach forEach() 方法指定数组的每项元素都执行一次传入的函数,返回值为undefined 语法：arr.forEach(fn, thisArg); fn表示在数组每一项上执行的函数,接受三个参数： value 当前正在被处理的元素的值 index 当前元素的数组索引 array 数组本身 forEach将为数组中每一项执行一次fn函数,那些已删除,新增或者从未复制的项将被跳过( 但不包括值为undefined的项 ) 12345678var array = [1, 3, 5];var obj = &#123;name: 'shen'&#125;;var sReturn = array.forEach(function(value, index, array)&#123; array[index] = value * value; // console.log(this.name);&#125;);console.log(array); // [1, 9, 25] 原数组被改变console.log(sReturn); // undefined 返回值 使用forEach循环 需要注意的几点 forEach无法直接遍历对象 ( 通过call方式遍历类数组对象 ) forEach无法再IE中使用,只是在Firefox和Chrome中实现了该方法 forEach无法使用break、continue跳出循环,使用return时,效果和在for循环中使用continue一致 12345678910var oFunction = &#123; 0:1, 1:3, 2:5, length: 3&#125;;Array.prototype.forEach.call(oFunction,function(value, index, obj)&#123; console.log(value,index,obj); obj[index] = value * value;&#125;,oFunction); 兼容写法请参考 Polyfill。 Map map() 方法遍历数组,使用传入函数处理每个元素,并返回函数的返回值组成的新数组 只支持数组 参数介绍同 forEach 方法的参数介绍。 语法：arr.map(fn, thisArg); map方法使用其提供函数的每次返回结果生成一个新的数组 12345678910111213141516171819202122var array = [1, 4, 9];var roots = array.map(function(num)&#123; return num * 2;&#125;);# 鸭式辨型// NodeListvar elems = document.querySelectorAll('select option:checked');var values = Array.prototype.map.call(elems, function(obj)&#123; return obj.value;&#125;);// 字符串处理var map = Array.prototype.map;var array = map.call('Hello 中国',function(x)&#123; return x.charCodeAt(0);&#125;);console.log(array);// 字符串反转var str = '12345';var output = Array.prototype.map.call(str, function(x)&#123; return x;&#125;).reverse().join('/');console.log(output); 兼容写法请参考 Polyfill。 forEach和map 区别 map() 方法返回：原数组中的每个元素调用一个指定方法后返回值组成的新数组。返回一个新的Array forEach 为数组中的每个元素执行一次回调函数,返回值 “ undefined ”。没有返回值,只是针对每个元素调用func every array.every(callback[, thisArg]) every方法用于检验数组中的每一项是否符合某个条件,若符合则返回true,反之返回false。 只要其中一个函数返回值为false,那么该方法的结果为false,如果全部返回true,那么该方法的结果才为true 12345678910111213141516171819function isBigEnough(element, index, array)&#123; return element &gt;= 10;&#125;[12, 5, 8, 120, 45].every(isBigEnough);// false[12, 54, 18, 289, 98].every(isBigEnough);// true# 简写[12, 5, 8, 120, 45].every(elem =&gt; elem &gt;= 10);[12, 54, 18, 289, 98].every(elem =&gt; elem &gt;= 10);# 鸭式辨型var oFunction = &#123; 0: 10, 1: 8, 2: 25, length: 3&#125;;var bool = Array.prototype.every.call(oFunction,function(value, index)&#123; return value &gt;= 8;&#125;,oFunction);console.log(bool); 兼容写法请参考 Polyfill。 some some() 方法刚好痛every() 方法相反,some测试数组元素时,只要有一个函数返回值为true,则返回true,若全部返回false,则方法返回false 兼容写法请参考 Polyfill。 every和some区别 every：返回一个boolean，判断每个元素是否符合func条件 some：返回一个boolean，判断是否有元素符合func条件 filter 返回一个符合func条件的元素数组 filter() 方法使用传入的函数测试所有元素,并返回所有通过测试的元素组成的新数组。它就好比一个过滤器,筛掉不符合条件的元素 语法：arr.filter(fn, thisArg); 12345var array = [18, 9, 10, 35, 99];var array2 = array.filter(function(value, index, array)&#123; return value &gt; 20;&#125;);console.log(array2); reduce reduce() 方法接受一个方法作为累加器,数组中的每个值( 从左至右 )开始合并,最终为一个值 语法：arr.reduce(fn, initialValue); fn表示在数组每一项上执行的函数,接受四个参数 previousValue 上一次调动回调返回的值 value 数组中读取被处理元素的值 index 当前元素在数组中的索引 array 数组自身 12345var array = [1, 2, 3, 4, 5];var s = array.reduce(function(previousValue, value, index, array)&#123; return previousValue * value;&#125;,1);console.log(s); find和findIndex(ES6) find() 返回数组中第一个满足条件的元素 ( 如果有的话 ),如果没有,则返回undefined findIndex() 返回数组中第一个满足条件的元素的索引 ( 如果有的话 ),否则返回-1 1234567891011var array = [1, 3, 5, 7, 8, 9, 10];function f(value, index, array)&#123; return value %2 == 0;&#125;function f2(value, index, array)&#123; return value &gt; 20;&#125;console.log(array.find(f));// 8console.log(array.find(f2));// undefinedconsole.log(array.findIndex(f));// 4console.log(array.findIndex(f2));// -1 Kes( ES6 ) keys() 方法返回一个数组索引的迭代器 Array.prototype 本身就是一个数组,并且他的长度为0 Array.prototype.map、Array.prototype.every只支持数组和行似数组的对象 forEach不能退出循环,只能通过return来进入到下一个元素的遍历中( 相当于for循环的continue ),IE中没有实现该方法 for、forEach、do/while 只支持数组 for in , $.each,即支持对象也支持数组遍历 $.each循环只能通过 return false来退出循环,使用return 或 return true 将跳过一个元素,继续执行后面的循环 Array.prototype 共性 所有插入元素的方法,比如push、unshift,一律返回数组新的长度 所有删除元素的方法,比如pop、shift、splice一律返回删除的元素,或者返回删除的多个元素组成的数组 部分遍历方法,比如 forEach 、 map 、 filter 、 find 、 findIndex 、 every ，都包含了 function(value, index, array){} 和 thisArg 这样两个形参 Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性。它们不止可以用来处理数组对象,还可以处理类数组对象 Array.prototype本身就是一个数组，并且长度为0 forEach 123456var array = [1, 3, 5];array.forEach(function(value, index, array)&#123; console.log('value值:' + value); console.log('索引值:' + index) console.log('数组:' + array);&#125;); map 创建新数组,其结果是该数组中的每个元素调用一个提供的函数1234567891011121314151617181920212223242526272829303132var array = [1, 3, 5];var doubles = array.map(function(num)&#123; return num * 2;&#125;);console.log(doubles);// 求数组中每个元素的平方根var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);console.log(roots);// 使用map重新格式化数组中的对象// 将一个包含对象的数组用以创建一个包含重新格式化对象的新数组var ary = [&#123; key: 1, value: 10&#125;,&#123; key: 2, value: 20&#125;,&#123; key: 3, value: 30&#125;];var arys = ary.map(function(obj)&#123; var rObj = &#123;&#125;; rObj[obj.key] = obj.value * 2; return rObj&#125;);console.log(arys);// 获取和遍历 querySelectorAll 得到的动态对象集合var elems = document.querySelectorAll('select option:checked');var values = Array.prototype.map.call(elems, function(obj)&#123; return obj.value;&#125;) filter 12345var array = [1, 3, 5, 7, 9, 11];var array2 = array.filter(function(value, index, array)&#123; return value &gt; 5;&#125;);console.log(array2); find() 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined1234567891011121314151617// 示例1var array = [1, 3, 5, 7, 9, 11];function foo(value, index, array)&#123; return value % 2 == 0; // return value &gt;= 5&#125;;console.log(array.find(foo));// 示例2:用对象的属性查找数组里的对象var inventory = [ &#123;name: 'apples', quantity: 2&#125;, &#123;name: 'bananas', quantity: 0&#125;, &#123;name: 'cherries', quantity: 5&#125;];function findCherries(fruit)&#123; return fruit.name === 'apples';&#125;;console.log(inventory.find(findCherries)); indexOf() 找到一个元素的位置12345678910111213141516// 返回在数组中可以找到給定元素的第一个索引,如果不存在,则返回 -1var array = [1, 3, 5];if(array.indexOf(7) === -1)&#123; alert('哈哈、没有找到');&#125;// 找出指定元素出现的所在位置// 返回在数组中可以找到給定元素的第一个索引,如果不存在,则返回 -1var array = ['a', 'b', 'a', 'c', 'a', 'd'];var indices = [];var idx = array.indexOf('a')while(idx !== -1)&#123; indices.push(idx); idx = array.indexOf('a', idx + 1);&#125;console.log(indices); includes() 判断一个元素是否存在于数组中12345// 用来判断当前数组是否包含某个指定的值,如果是,则返回true,否则返回false[1, 2, 3].includes(2); // true(function()&#123; console.log([].include.call(arguments, 'a'));&#125;)('a','b','c')； 循环遍历 for( 只能遍历数组 )和do while( 只能遍历数组 ) forEach、map、every ( Array.prototype下的所有方法,它们不止可以用来处理数组对象,还可以处理类数组对象 ) $.each() for in ECMAScript2015中Array引进的新方法 forEach()和map() 数组内置遍历方法 forEach()和map() 最近再扒数组中的API forEach()和map()方法是ECMAScript5.1中Array引进的新方法 forEach - 遍历forEach循环数组,对原数据进行操作,改变原数组 总是返回 undefined、并且不可链式调用。 没有办法终止或者跳出forEach循环。如果你需要这样,那么使用forEach()方法是个错误的决定。 如果您正在测试一个数组里的元素是否符合某种条件,且需要返回一个布尔值的话,那么可以使用 Array.every 或 Array.some 。当然也可以使用ES6里的新方法 find() 或 findIndex() 他们也可被用于真值测试的提前终止。 forEach无法使用break, continue跳出循环,使用return时,效果等同于for循环的continue。 如果使用箭头函数表达式传入函数参数,thisArg参数会被忽略,因为箭头函数在词法上绑定了this值( 箭头函数绑定的this无法被修改 ) 如果給forEach传递了thisArg参数,当调用时,它将被传给callback函数,作为它的this值。如果省略了thisArg参数,或者赋值为null或undefined,则this指向全局对象 forEach遍历的范围在第一次调用callback前就已经确定。调用forEach后添加到数组中的项不会被callback访问到。如果已经存在的值被改变,则传递給callback的值是forEach遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了,之后的元素将被跳过 1234567891011var ary = [1, 3, 5];console.log('原数组1：' + ary);var res = ary.forEach(function(item, index, array)&#123; // item: 数组当前项的值 // index: 数组当前项的索引 // array: 数组对象本身 array[index] = item * 10;&#125;, ary);// ary(可选)。当执行回调函数时用作this的值console.log('返回值：' + res);console.log('原数组2：' + ary); 兼容写法请参考 Polyfill。 map - 映射创建新数组 使用map方法处理数组时,数组元素的范围是在callback方法第一次调用之前就已经确定了。在map方法执行的过程中：原数组中新增加的元素将不会被callback访问到; 若已经存在的元素被改变或删除了，则他们的传递到callback的值是map方法遍历到它们的那一时刻的事件; 而被删除的元素将不会被访问到 基本用法类似forEach、需要注意的是: 回调函数需要有return值,否则新数组都是 undefined 123456var ary = [1,2,3,4,5]; var res = ary.map(function (item,index,input) &#123; return item*10; &#125;) console.log('新数组：' + res);console.log('原数组：' + ary); 兼容写法请参考 Polyfill。 forEach()和map()两个方法都是ECMAScript2015中Array引进的新方法 主要的作用是对数组的每个元素执行一次提供的函数。 区别 forEach() 返回值是 undefined,不可以链式调用 map() 返回一个新数组,原数组不会改变 没有办法终止或者跳出forEach()、map()循环,除非抛出异常,因此想执行一个数组是否满足什么条件,返回布尔值,可以用一般的for循环实现,或者用Array.every()或者Array.some()或者Array.filter() 使用for循环过滤一遍搞定的事情,偏偏再用every之类的再次过滤,这就有点愚蠢了 1234567891011121314151617// 案例1 反转字符串(map、call)方法的融合使用var str = '12345';Array.prototype.map.call(str,function(item)&#123; return item;&#125;).reverse().join('');// 案例2 如果数组在迭代时被修改了,则其他元素会被跳过// 当到达含值"two"的项时,整个数组的第一项被移除了,这就导致所有剩下的内容,集体向前移了一个位置。因为元素"for"现在在数组的第三个位置,"three"会被跳过。var words = ["one","two","three","four"];words.forEach(function(item)&#123; console.log(item); if(item === "two")&#123; words.shift(); &#125;&#125;);// one// two// four map()、forEach()、for三个循环在什么时候使用比较合适 如果需要返回一个数组,使用map()比较合适 有时候循环并不需要全部遍历完,需要中途跳出break、这要使用for( 当然也可以使用、这就需要使用filter()、some()… 进行二次过滤( 可读性会好点 ) ) map()和forEach() 适合在按准许全部遍历的时候使用 数组内置遍历方法 forEach()和map() REM document.documentElement.style.fontSize = 100 * (clientWidth / 640) + &#39;px&#39; clientWidth：当前用户屏幕 640：设计稿大小 100：方便计算 rem：CSS3新增的一个相对单位、根据html( DOM结构的根节点元素 )的font-size大小来变化 以640px的设计布局为基准,将html设置为font-size: 100px;( 为了方便计算 ) 1rem = 100px; 可以将大部分px单位除以100就可以直接改成rem单位 122px = 1.22rem; 18px = 0.18rem; 640宽度的设计稿在Iphone6S( 750宽度 ) 设计稿宽度为640px; 物理设备宽度为750px( Iphone6S ); 有一个元素在设计稿上的宽是 50 那么根据比率计算出实际设备里面的宽度 ？58.6px = 3.6621rem; 默认1rem = 16px$$(750/640) * 50 = 58.6 = 3.6621rem; 1rem = 16px;$$ 1rem = 16px; (750 / 640) * 50 / 16 = 3.6621rem; 1rem = 100px; (750 / 640) * 50 / 100 = 0.5859rem; 修改的值为fontSize： (750 / 640) * 50 / ??? = 0.5859rem; (750 / 640) * 50 / ? = .5rem; (750 / 640) * 100 = fontSize; 12345678// 设计稿宽度为640px;// 物理设备宽度为750px( Iphone6S );// 有一个元素在设计稿上的宽是 50// 那么根据比率计算出实际设备里面的宽度 ？(750 / 640) * 50 / 16 = 3.6621rem;// 如果默认的fontSize不修改、则如此计算(750 / 640) * 50 / 100 = 0.5859rem;(750 / 640) * 50 / ? = .5rem; Array中的遍历方法(12) forEach、map every、some、filter ( 三种过滤规则 - 鸭式辨型 类似 ) reduce、reduceRight find、findIndex、keys、values、entries( ES6 ) every every() 方法测试数组的所有元素是否都通过了指定函数的测试 arr.every(callback[, thisArg]); every不会改变原数组 every方法为数组中的每个元素执行一次callback方法，直到它找到一个使callback返回 false ( 转化为布尔值false ) 的元素。如果发现了一个这样的元素，every方法将会立即返回false。否则，callback为每一个元素返回true，every就会返回true callback只会为那些已经被赋值的“ 索引 ” 调用。不会为那些已经被删除或者从来没被赋值的索引调用。 every遍历的元素范围在第一次调用callback之前就已确定了。在调用every之后添加到数组中的元素不会被callback访问到。如果数组中存在的元素被更改,则他么传入callback的值是every访问到他们那一刻的值。那些被删除的元素或从来未被复制的元素将不会被访问到 every提供一个thisArg参数，如果省略该参数，则callback被调用时的this值，在非严格模式下为全局对象，在严格模式下传入undefined 12345678910111213141516function isBigEnough(item, index, array) &#123; return (item &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);console.log(passed);// 鸭式辨型var o = &#123; 0: 10, 1: 8, 2: 25, length: 3&#125;;var bool = Array.prototype.every.call(o,function(value, index, obj)&#123; return value &gt; 10;&#125;);console.log(bool); 兼容写法请参考 Polyfill some some()：测试数组中的 ‘某些元素’ 是否通过了指定函数的测试 every()：测试数组的 ‘所有元素’ 是否都通过了指定函数的测试 some为数组中的每一个元素执行一次callback函数，直到找到一个使得callback返回一个“真值” ( 即可转换为布尔值true的值 )。如果找到这样的值，some将会立即返回true。否则，some返回false。 every方法为数组中的每一个元素执行一次callback方法，直到它找到一个使callback返回 false ( 转化为布尔值false ) 的元素。如果发现了一个这样的元素，every方法将会立即返回false。否则，callback为每一个元素返回true，every就会返回true 兼容写法请参考 Polyfill filter filter()：使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组 callback 返回true表示保留该元素( 通过测试 ) filter为数组中的每个元素调用一次callback函数，并利用所有使得callback返回true的元素创建一个新数组。 callback只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用 那些没有通过callback测试的元素会被跳过，不会被包含在新数组中。 1234var filtered = [12, 5, 8, 130, 44].filter(function(el, index, array)&#123; return el &gt; 10;&#125;);console.log(filtered); 兼容写法请参考 Polyfill reduce reduce() 方法接受一个方法作为累加器，数组中的每个值( 从左到右 ) 开始合并，最终为一个值。 reduce() 方法对累加器和数组中的每个元素( 从左到右 )应用一个函数，将其减少为单个值。 语法1：arr.reduce(fn, initialValue); 语法2：arr.reduce(callback,[initialValue]); 参数 callback：执行数组中每个值的函数，包含四个参数 accumulator：上一次调用回调返回的值，或者是提供的初始值( initialValue ) currentValue：数组正在处理的元素 currentIndex：数据中正在处理的元素索引，如果提供了 initialVlaue，从0开始; 否则从1开始 initialValue ( 可选 ) 用于第一次调用 callback 的第一个参数 array 如果initialValue在调用reduce时被提供，那么第一个previousValue将等于initialValue，此时item等于数组中的第一个值 如果initialValue未被提供，那么previousValue等于数组中的第一个值，item等于数组中的第二个值。 reduce 为数组中的每一个元素一次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值 accumulator ( 或者上一次回调函数的返回值 )，当前元素值 currentValue，当前索引 currentIndex，调用 reduce的数组 回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供 initialValue， 注：不提供 initialValue，reduce会从索引1的地方开始执行 callback 方法，跳过第一个索引。 提供 initialValue，从索引0开始。 12345678910111213141516var array = [1, 2, 3, 4];var s = array.reduce(function(previousValue, value, index, array)&#123; return previousValue * value;&#125;,1)console.log(s);// 乘积# 计算数组中各个值出现的次数var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];var countedNames = names.reduce(function(allNames, name)&#123; if(name in allNames)&#123; allNames[name]++; &#125;else&#123; allNames[name] = 1; &#125; return allNames;&#125;, &#123;&#125;);console.log(countedNames); find和findIndex find()：返回数组中第一个满足条件的元素，如果没有，则返回undefined findIndex()：返回数组中第一个满足条件的元素的索引，否则返回-1 语法：arr.find(fn, thisArg), arr.findIndex(fn, thisArg) 语法和使用方式与 forEach 十分相似。 123456789101112131415var array = [1, 3, 5, 6, 7, 9, 10, 11];function odd(value, index, array)&#123; return value%2 == 0;&#125;console.log(array.find(odd));// 用对象的属性查找数组里的对象var inventory = [ &#123;name: 'apples', quantity: 2&#125;, &#123;name: 'bananas', quantity: 0&#125;, &#123;name: 'cherries', quantity: 5&#125;];function findEl(item)&#123; return item.name === 'apples';&#125;console.log(inventory.find(findEl)); indexOf 找到一个元素的位置或者一个元素是否存在于数组中。 返回在数组中可以找到給定元素的第一个索引，如果不存在，则返回-1 语法： arr.indexOf(searchElement), arr.indexOf(searchElement[, fromIndex = 0]); fromIndex：开始查找的位置。如果该索引值大于或等于数组长度，意味着不会再数组里查找，返回-1。 如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找，以此类推。 1234567891011121314151617181920212223// 找出指定元素出现的所在位置var array = ['a', 'b', 'a', 'c', 'a', 'd'];var ary2 = [];var el = 'a';var idx = array.indexOf(el);while(idx != -1)&#123; ary2.push(idx); idx = array.indexOf(el, idx + 1);&#125;console.log(ary2);// 判断一个元素是否存在数组里，不在则跟新数组function updateAry(ary, el)&#123; if(ary.indexOf(el) === -1)&#123; ary.push(el); console.log('新的数组：' + ary); &#125;else if(ary.indexOf(el) &gt; -1)&#123; console.log(el + '：已经存在 in the ary'); &#125;&#125;var veggies = ['potato', 'tomato', 'chillies', 'green-pepper'];updateAry(veggies,'ntscshen');updateAry(veggies,'tomato'); String方法match 当一个字符串与一个正则表达式匹配时，match() 方法检索匹配项str.match(regexp) 如果正则表达式没有g标志，则str.math() 会返回和 RegExp.exec() 相同的结果 如果正则表达式包含了g标志，则该方法返回一个Array，它包含所有匹配的子字符串而不是匹配对象。如果没有匹配到，则返回null ​regexp：如果传入一个非正则表达式对象，则会隐式地使用new RegExp(obj)将其转换为一个 RexExp。如果未提供任何参数，直接使用match()，那么将会得到一个包含空字符串的Array：[“”]; 返回值：array 一个包含了整个匹配结果已经任何括号捕获的匹配结果Array；如果没有匹配项，则返回null 如果正则表达式没有g标志，则str.math() 会返回和 RegExp.exec() 相同的结果 返回的Array拥有一个额外的input属性，该属性包含被解析的原始字符串。 另外还拥有一个index属性，该属性表示匹配结果在原字符串中的所有(从0开始) match：若是全局匹配，则返回所有匹配的结果组成的数组g：用来在输入字符串中查找尽可能多的匹配i：大小写敏感replacesearchsplit 使用正则表达式的方法 JS中字符串对正则的支持：match：找到一个或多个正则表达式的匹配search：检索与正则表达式相匹配的值， g对search无效replace：替换与正则表达式匹配的子串split：把字符串分割为字符串数组 123456789window.location.href.match(/le.com/g,)1、如果包含le则替换成letv2、// 普通替换var str = 'some money';str.replace('some','much');// 使用正则进行全局替换var str = 'some money';str.replace(/o/g,'S'); browserSync Talk about your preferred development environment. 谈谈你首选的开发环境 If you could master one technology this year, what would it be? 如果你能在今年掌握一种技术，那会是什么？ What did you learn yesterday/this week? 你学到了什么在昨天/这周 What is a recent technical challenge you experienced and how did you solve it? 你近期经历了什么技术挑战，你是怎么解决的呐？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsonp]]></title>
      <url>%2F2017%2F04%2F14%2Fjsonp.html</url>
      <content type="text"><![CDATA[很简单，就是利用标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个元素，地址指向第三方的API网址，形如： 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： callback({“name”:”hax”,”gender”:”Male”}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 补充：“历史遗迹”的意思就是，如果在今天重新设计的话，也许就不会允许这样简单的跨域了嘿，比如可能像XHR一样按照CORS规范要求服务器发送特定的http头。 https://www.zhihu.com/question/19966531]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小米5下line-height问题]]></title>
      <url>%2F2017%2F04%2F13%2F%E5%B0%8F%E7%B1%B35%E4%B8%8Bline-height%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[在小米5(Android)上总是发现文字偏上 原因：line-height对一部分Android手机不起作用,有自己的默认行高,默认行高为22px( 有待考证 ) 解决办法123line-height: 0;padding: 10px 0; /* 高度修改为对应的padding值 */font-size: 12px; /* 此处需为px、不可使用rem */]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快捷设置CSS3动画]]></title>
      <url>%2F2017%2F03%2F28%2F%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AECSS3%E5%8A%A8%E7%94%BB.html</url>
      <content type="text"><![CDATA[来历：在开发一个CSS3动画N多的页面时、我们主体在做的是复制、复制、复制。然后修改 运动效果 、 运动延迟时间 、 运动持续时间 。 原有模式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 持续时间 &amp;&amp; */.animated &#123; -webkit-animation-duration: 1s; animation-duration: 1s; -webkit-animation-fill-mode: both; animation-fill-mode: both&#125;/* 无限的 */.animated.infinite &#123; -webkit-animation-iteration-count: infinite; animation-iteration-count: infinite&#125;/* 从右弹入 */@-webkit-keyframes bounceInRight &#123; 0% &#123; opacity: 0; -webkit-transform: translateX(2000px); transform: translateX(2000px) &#125; 60% &#123; opacity: 1; -webkit-transform: translateX(-30px); transform: translateX(-30px) &#125; 80% &#123; -webkit-transform: translateX(10px); transform: translateX(10px) &#125; 100% &#123; -webkit-transform: translateX(0); transform: translateX(0) &#125;&#125;@keyframes bounceInRight &#123; 0% &#123; opacity: 0; -webkit-transform: translateX(2000px); -ms-transform: translateX(2000px); transform: translateX(2000px) &#125; 60% &#123; opacity: 1; -webkit-transform: translateX(-30px); -ms-transform: translateX(-30px); transform: translateX(-30px) &#125; 80% &#123; -webkit-transform: translateX(10px); -ms-transform: translateX(10px); transform: translateX(10px) &#125; 100% &#123; -webkit-transform: translateX(0); -ms-transform: translateX(0); transform: translateX(0) &#125;&#125;.bounceInRight &#123; -webkit-animation-name: bounceInRight; animation-name: bounceInRight&#125; 123&lt;li class="ani bounceInRight animated" style="animation-delay:.9s;-webkit-animation-delay:.9s;-webkit-animation-duration: 2s;animation-duration: 2s;"&gt;A.颜值担当&lt;/li&gt;&lt;li class="ani bounceInRight animated" style="animation-delay:1.2s;-webkit-animation-delay:1.2s;-webkit-animation-duration: 2s;animation-duration: 2s;"&gt;B.颜值担当&lt;/li&gt;&lt;li class="ani bounceInRight animated" style="animation-delay:1.5s;-webkit-animation-delay:1.5s;-webkit-animation-duration: 2s;animation-duration: 2s;"&gt;C.颜值担当&lt;/li&gt; 使用动态修改123456&lt;li class="s-an" effect="bounceInRight" delay=".4s" duration="1s"&gt;A.颜值担当&lt;/li&gt;&lt;!--effect:效果delay:延期duration:持续 --&gt; 12345678910111213141516171819202122232425262728293031/** * [setAnimate 设置CSS3动画(便捷)] */function setAnimate() &#123; var oAni = document.querySelectorAll('.s-an'); for (var i = 0; i &lt; oAni.length; i++) &#123; var effect = oAni[i].getAttribute('effect') ? oAni[i].getAttribute('effect') : ''; var duration = oAni[i].getAttribute('duration') ? oAni[i].getAttribute('duration') : ''; var delay = oAni[i].getAttribute('delay') ? oAni[i].getAttribute('delay') : ''; // 获取style信息 var style = oAni[i].getAttribute('style') ? oAni[i].getAttribute('style') : ''; // 设置CSS3动态特效名称 oAni[i].className = oAni[i].className + ' ' + effect + ' ' + 'animated'; // 设置持续时间 duration &amp;&amp; (style = style + 'animation-duration:' + duration + ';-webkit-animation-duration:' + duration + ';') // 设置延迟时间 delay &amp;&amp; (style = style + 'animation-delay:' + delay + ';-webkit-animation-delay' + delay + ';'); // 设置style oAni[i].setAttribute('style', style); &#125;&#125;setAnimate(); 留下您的脚步~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack初涉]]></title>
      <url>%2F2017%2F03%2F09%2Fwebpack%E5%88%9D%E6%B6%89.html</url>
      <content type="text"><![CDATA[webpack2的简易构建(传送门) 在写此文章时：正直webpack2.2发布没多久。 webpack1.x和webpack2.x 整体上只有稍许区别，其他都一样 一个entry 一个output 一个loaders 一个plugins 最大的不同在于解析器的不同，基本上都是在做减法，将配置信息变得不那么容易写错，以及更好的命名规则 我想升级webpack2得到最大的收益就是：ES6规范的优化。意味着可以直接使用 import 以及 export,而不必再来一次CommonJS模块处理 定义默认的npm init 如果你厌倦了每次开始一个新的项目、都需要重新输入同样的信息，可以使用 -y标记表示你能接受 package.json 文件的一堆默认值 配合npm使用 CLI这种方式运行 webpack 不是特别方便。我们可以设置一些快捷方式 在 package.json 中的 scripts 内添加CLI中的内容 12345678&gt; &#123;&gt; ...&gt; &quot;scripts&quot;: &#123;&gt; &quot;start&quot;: &quot;webpack&quot;&gt; &#125;,&gt; ...&gt; &#125;&gt; 这样就可以通过 npm run start 命令来实现与上面相同的效果。 npm通过命令选取脚本,并临时修补执行环境,使脚本可以在运行时包含bin命令。 如果你在项目中使用了npm执行脚本,npm 首先 会在你的本地模块中寻找webpack。 生产环境的构建JS文件压缩 webpack自带 UglifyJsPlugin 手动方式：为多环境配置Webpack 当我们有针对多种环境分别配置的需求时,最简单的方式就是为不同的环境编写独立 Webpack插件( Plugins ) webpack自身也是构建在同样的插件系统上！插件的目的是在于解决 loader 无法实现的其他事。 配置最简单的配置12345678var path = require('path');module.exports = &#123; entry: './foo.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'foo.bundle.js' &#125;&#125; 多个目标123456789101112131415161718192021222324252627var path = require('path');var webpack = require('webapck');var webpackMerge = require('webpack-merge');var baseConfig = &#123; target:'async-node', entry:&#123; entry:'./entry.js' &#125;, output:&#123; path:path.resolve(__dirname,'dist'), filename:'[name].js' &#125;, plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; name:'inline', filename:'inline.js', minChunks:Infinity &#125;), new webpack.optimize.AggressiveSplittingPlugin(&#123; minSize:5000, maxSize:10000 &#125;) ]&#125;;module.exports = targets;// es6写法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git使用指南-1]]></title>
      <url>%2F2017%2F03%2F03%2FSourceTree%3AGit%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97.html</url>
      <content type="text"><![CDATA[飞机票：https://github.com/Mark24Code/15minGitSourceTree/Git轻指南 场景1：创建仓库,提交代码场景2：通过分支,来完成个人工作场景3：多人协作,分支 + 解决冲突 创建git仓库 基本的提交操作 分支与合并 123456789101112131415&lt;body&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD &lt;h1&gt;这是冲突A&lt;/h1&gt;======= &lt;h1&gt;这是冲突B&lt;/h1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; testB&lt;/body&gt;HEAD是一个指针变量,它指向誰,就表明你在哪个分支。 HEAD -&gt; master在其他分支的时候同理。所以这里HEAD开头和=====之间的部分就是指当前你的修改。而下半部分，就是合并分支的部分。解决冲突方案：1、删除我的保留其他分支的2、删除其他分支的保留我的3、去掉奇怪的字符，保存大家的 场景1：创建仓库,提交代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端适配精灵图(sprite雪碧图)]]></title>
      <url>%2F2017%2F03%2F03%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E7%B2%BE%E7%81%B5%E5%9B%BE-sprite%E9%9B%AA%E7%A2%A7%E5%9B%BE.html</url>
      <content type="text"><![CDATA[移动端精灵图可以使用按照PC端的进行移植、只是把 background-position: 1rem 3.1rem; 对应的px转换成rem即可 大体上这样适配没什么问题,如果公司要求不是很严格的话 在一些手机里面,会有一切缺陷,有些图片少了那么1px。但是本着进益求精的原则，解决方案总结如下：(使用百分比方式、需要sass的mixin进行封装) background-position详解 属性值为百分比时，将以图片的 中心点 为基准计算其相对位置。 W3C怎么说： 12345678&gt; With a value pair of '0% 0%', the upper left corner of the image is aligned with the upper left corner of the box's. A value pair of '100% 100%' places the lower right corner of the image in the lower right corner of padding area. With a value pair of '14% 84%', the point 14% across and 84% down the image is to be placed at the point 14% across and 84% down the padding area.&gt; 我这渣渣英语翻译大致如下：&gt; 1、background-position: 0% 0%;图像的左上角和父级的左上角对齐&gt; 2、background-position: 100% 100%;图像的右下角和父级的右下角对齐&gt; 3、background-position: 14% 84%;图像的中心点14% 84%。将被放置在父级的14% 84%的位置&gt; 总结1：也就是说如果用百分比来作为 background-position的属性值的话,那么背景图片相对于容器的中心点事随时都在改变的。&gt; 总计2：background-position: 10% 20%; 背景图片首先会把自身的中心点移动到10% 20%的位置。然后在根据父级元素的宽高来移动(10% 20%)&gt; &gt;&gt; 属性值为像素时，始终以图片的 左上角 为基准。 原文传送门 例子123456789101112131415/*1、当前图片宽高为(200*200);2、当前元素大小为(100*100);图片的原中心点是(0, 0)现在的中心点位置是(200*10%, 200*20%),也就是(20px, 40px)。按照之前的推理：1、图片以(20px,40px)为中心点,移动元素宽度的10%,元素高度的20%,也就是移动了(10px,20px);2、最终移动的距离是：(-20px+10px,-40px+20px) === (-10px,-20px);*/.box&#123; width: 100px; height: 100px; background: url(demo.png) no-repeat;// 当前图片宽高为200*200 background-position: 10% 20%;&#125; 公式计算 根据如上的推理,我们若想得到定位的百分比值, 我们需要元素的宽高 (eleWidth,eleHeight) ,图片的宽高 (imgWidth,imgHeight) ,当前图片移动后的坐标 imgX,imgY left: -imgX/(eleWidth-imgWidth)*100%; top:-imgY/(eleHeight-imgHeight)*100%; 使用传送门 1234567891011121314151617//$spriteWidth 雪碧图的宽度px//$spriteHeight 雪碧图的高度px//$iconWidth 需要显示icon的宽度px//$iconHeight 需要显示icon的高度px//$iconX icon的原始x坐标//$iconY icon的原始y坐标//@mixin bgPosition($spriteWidth, $spriteHeight, $iconWidth, $iconHeight, $iconX, $iconY)&#123; background-position: (($iconX / ($spriteWidth - $iconWidth)) * 100% ($iconY / ($spriteHeight - $iconHeight)) * 100%);&#125;.icon2&#123; width: 0.74rem; height: 0.64rem; @include bgPosition(1072, 442, 74, 64, 188, 5);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运行机制]]></title>
      <url>%2F2017%2F03%2F01%2FJavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html</url>
      <content type="text"><![CDATA[前言：由于活动需要做了一个倒计时、如果当前页面 运行时间长了、新开的页面和原打开页面会存在很大误差。 原因可能是JS的单线程阻塞了定时器的执行。说到单线程就不得不说JS的运行机制 为什么JavaScript是单线程？为什么不能是多线程？作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 任务队列 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等待 JS只有一个主线程，主线程执行完执行栈的任务后去检查异步的任务队列，如果异步事件触发，则将其加到主线程的执行栈 HTML5：setTimeout的最小间隔：是W3C在HTML标准中规定，要求低于4ms的事件间隔算为4ms]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS活动精准倒计时]]></title>
      <url>%2F2017%2F03%2F01%2FJS%E6%B4%BB%E5%8A%A8%E7%B2%BE%E5%87%86%E5%80%92%E8%AE%A1%E6%97%B6.html</url>
      <content type="text"><![CDATA[前端页面倒计时功能在很多场景中会被使用，比如运营活动 ( 开始倒计时、活动结束倒计时、抢购倒计时 )、 倒计时的开始获取时间应该读取服务器返回时间。但实际证明，做了这一步还远远不够，页面运行时间长了，新开的页面和原打开页面还是存在误差。 造成误差的原因主要有几种可能 没有考虑页面渲染和函数运行累计时间 主要原因 没有考虑JS冻结运行耗费的时间 其他逻辑问题 由于JS是单线程执行，同一时间只能执行一个JS代码( 同一时间其他异步事件执行会被阻塞 )，当异步事件发生时，它会进入代码执行队列，执行线程时依照队列顺序依次执行代码 当你的页面没有处于被浏览的状态时，这个网页的JS不会运行或者暂时阻塞，这是浏览器为了节省资源的行为，各个浏览器做法不大一样]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-装饰者模式(7)]]></title>
      <url>%2F2017%2F02%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F(7).html</url>
      <content type="text"><![CDATA[聊装饰者之前、咱们先写一下单一职责原则。 单一职责原则 问题由来：类T负责两个不同的职责，职责P1、职责P2。当由于职责P1需求发生改变而需求修改T时，有可能会导致原本运行正常的职责P2功能发生故障 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 在软件编程中，誰也不希望因为修改一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。 不遵循单一职责原则：这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1,P2,P3,P4…..Pn。所以，牢记一点，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构 OOD( Object-Oriented Design )：面相对象设计 使代码更清晰 无需更改现有代码就可扩展可复用 能应对很多变化：如修改或添加或删除某一部分代码，并不会影响到另一部分代码 大多数项目中最不稳定的东西就是需求，我们生活在一个需求不断变化的事件中，我们必须确保我们的软件能禁得住这些考验 在程序开发中，许多时候都不希望某个类天使就非常庞大，一次性包含许多职责 装饰者模式( Decorator )： 在不改变原对象的基础上,通过对其进行包装扩展( 添加属性或者方法 ) 使原有对象可以满足用户的更复杂需求。 使用AOP装饰函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack基础]]></title>
      <url>%2F2017%2F02%2F24%2Fwebpack%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[Loaders:装载 babel的配置选项Babel完全可以在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的 webpack.config.js 文件中进行配置往往使得 这个文件 显得异常复杂，因此一些开发者支持把 babel 的配置选项放在一个单独的名为 .babelrc 的配置文件中， loaders是在打包构建过程中用来处理源文件的( JSX,SCSS… )，一次处理一个 插件并不直接操作单个文件，它直接对整个构建过程起作用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm故障排除]]></title>
      <url>%2F2017%2F02%2F24%2Fnpm%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4.html</url>
      <content type="text"><![CDATA[npm下许多常见的问题可以通过以下步骤之一进行解决： 1、尝试最新的稳定版本 在OSX、Linux中可能需要使用前缀 sudo sudo：超级管理员权限 升级最新版本：npm install -g npm@latest 升级最新的LTS(长期支持)版本： npm install -g npm@lts 查看当前全局npm下的安装包： npm list -g —depth 0 window请自行搜索😯 2、尝试清除npm缓存清除缓存：npm cache clean 如果遇到奇怪的问题，可以通过清除缓存、再试一次。 3、npm坏了重新安装： curl -L https://www.npmjs.org/install.sh | sh 4、文件名错误 拒绝在webpack目录下，安装webpack作为自身的依赖。你的项目名和安装的依赖项是否相同。 这种通常发生在工作文件夹名称与您尝试安装的软件包名称相同。并且已经运行了 npm init 使 package.json 文件具有和依赖项相同的名称 直白一点就是： package.json里面name不能和当前项目的文件名相同。 参考：npm官方Troubleshooting 参考：npm/issues/12121]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《Canvas系列》- 三角函数]]></title>
      <url>%2F2017%2F02%2F22%2F%E3%80%8ACanvas%E7%B3%BB%E5%88%97%E3%80%8B-%20%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.html</url>
      <content type="text"><![CDATA[开始学习三角函数之前,先要搞明白 javascript中的Math都有哪些方法. Math对象并不想Date和String那样是对象的类,因此没有构造函数Math(),像Math.sin()这样的函数只是函数,不是某个对象的方法.无需创建它,通过把Math作为对象使用就可以调用其所有属性和方法 Math随机数函数Math.random(); 返回0到1之间的随机数 Math四舍五入相关函数1234Math.round(); // 四舍五入Math.ceil(); // 向上取舍(天花板)Math.floor(); // 向下取舍(地板)Math.abs(); // 绝对值 Math最大最小类函数12Math.max(); // 返回数字中最大的值Math.min(); // 返回数字中最小的值 Math三角函数与属性12345678910Math.sin(); // 正弦值Math.cos(); // 余弦值Math.tan(); // 正切值Math.asin(); // 反正弦值Math.acos(); // 反余弦值Math.atan(); // 反正切值Math.atan2(); // 由X轴到点(x,y)的角度(以弧度为单位)Math.PI属性 // 圆周率π #### #### 上图简单的介绍了三角函数的表示方法,知道了三角函数表示的是角度和边之间的关系.但是在实际开发中我们不仅想要通过角度来推出两边的距离长度比值,而 更加关心的是如果通过已知的距离来推导出角度( 坐标的位置好确定 ) .这里我们要用到 反三角函数 在 JavaScript 中的相应表示方法是 1234567sin(θ) ---&gt; Math.sin( θ * Math.PI/180 )cos(θ) ---&gt; Math.cos( θ * Math.PI/180 )tan(θ) ---&gt; Math.tan( θ * Math.PI/180 )θ = arcsin(x/R) ---&gt; Math.asin(x/R)*(180/Math.PI)θ = arccos(y/R) ---&gt; Math.acos(y/R)*(180/Math.PI)θ = arctan(x/y) ---&gt; Math.atan(x/y)*(180/Math.PI) 在 canvas 中采用的是弧度制 角度转成弧度 : θ * Math.PI/180 使用已知的距离来推导角度( Math.atan2(dy,dx) ) 注释：请注意这个函数的参数顺序，Y 坐标在 X 坐标之前传递。 atan2()方法返回从X轴 到 点(x,y) 之间的角度 三角函数的6种用法 角度和弧度互转 12弧度:radians = degrees * Math.PI / 180角度:degrees = radians * 180 / Math.PI 旋转( 弧度 ) 123dx = point.x - object.x;dy = point.y - object.y;旋转:object.rotation = Math.atan2(dy, dx); 平滑运动 123range:平行value = center + Math.sin(angle) * range;angle += speed; 圆形运动 123xposition = centerX + Math.cos(angle) * radius;yposition = centerY + Math.sin(angle) * radius;angle += speed; 椭圆运动 123xposition = centerX + Math.cos(angle) * radiusX;yposition = centerY + Math.sin(angle) * radiusY;angle += speed; 两点间的距离 123var dx = x2 - x1;var dy = y2 - y1;var dist = Math.sqrt(dx * dx + dy * dy);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-命令模式(6)]]></title>
      <url>%2F2017%2F02%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F(6).html</url>
      <content type="text"><![CDATA[command：命令 execute：执行 设计模式的主题：总是把不变的事物和变化的事物分离开来 命令模式( Command )：将请求与实现解耦并分支成独立对象，从而使不同的请求对客户端的实现参数化 命令模式：其实就是 回调 ( callback ) 函数的一个面向对象的替代品 1234567var viewCommand = (function()&#123; var Action = &#123; create: function()&#123;&#125;, display:function()&#123;&#125; &#125; return function exute()&#123;&#125;&#125;)();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-发布订阅模式(5)]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F(5).html</url>
      <content type="text"><![CDATA[发布-订阅模式( 观察者模式 )：定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布-订阅模式。 观察者模式在实际开发中非常常用。。。 只要我们增加在DOM节点上绑定过事件函数，那么我们就曾今使用过发布-订阅模式 12345document.body.addEventListener('click',function()&#123; alert(1);&#125;,false);document.body.click();// 监听用户点击的动作，当body节点被点击的时候，body节点便会向订阅者发布这条信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-迭代器模式(4)]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F(4).html</url>
      <content type="text"><![CDATA[迭代器模式：在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。 迭代器是优化循环语句的一种可行方案，它使得程序清晰易读。 在开发中，迭代器极大简化了代码中的循环语句，使代码结构清晰紧凑，然而这些简化了的循环语句实质上隐形地移到了迭代器中，这也解决了对象的使用者与对象内部结构之间的耦合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 传统的逻辑：if条件分支// 根据不同的浏览器，选择不同的删除方式// 函数getUploadObj中充斥了 try-cache和if-else条件分支var getUploadObj = function() &#123; try &#123; return new ActiveXObject("TXFTNActiveX.FTNUpload"); &#125; catch (e) &#123; if (supportFlash()) &#123; var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'; return $(str).appendTo($('body')); &#125; else &#123; var str = '&lt;input name="file" type="file"/&gt;' return $(str).appendTo($('body')); &#125; &#125;&#125;// 改进：迭代器模式// IE上传控件var getActiveUploadObj = function() &#123; try &#123; return new ActiveXObject("TXFTNActiveX.FTNUpload"); &#125; catch (e) &#123; return false; &#125;&#125;;// flashvar getFlashUploadObj = function() &#123; if (supportFlash()) &#123; var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'; return $(str).appendTo($('body')); &#125; return false;&#125;;// Form表单上传var getFormUploadObj = function() &#123; var str = '&lt;input name="file" type="file"/&gt;' return $(str).appendTo($('body'));&#125;;// 把判断中的每一个条件内容进行封装在函数中。使用迭代器模式进行迭代循环var iteratorUploadObj = function() &#123; for (var i = 0, fn; fn = arguments[i++]) &#123; var uploadObj = fn(); if (uploadObj !== false) &#123; return uploadObj; &#125; &#125;&#125;var uploadObj = iteratorUploadObj(getActiveUploadObj, getFlashUploadObj, getFlashUploadObj);/** * 获取不同上传对象的方法被隔离在各自的函数里互不干扰， * try、catch和if条件分支不在纠缠在一起， */// 所有模式的核心是：单一职责原则：应该只有一个引起变化的原因，如果对象承担了多项职责，这就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。。。😀// 每个函数都是独立单一的模块。不承担多余的职责。对象的改变也不会引起其他代码的一连串反应// 每一个功能独立封装(正确：return true。错误：return false)。再使用一个函数进行逻辑判断( 迭代定义的函数、正确的话则、停止参数否则继续执行 )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-代理模式(3)]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F(3).html</url>
      <content type="text"><![CDATA[代理模式( Proxy )：由于一个对象不能直接引用另外一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用 虚拟代理和缓存代理 图片预加载 12345678910111213141516// 没有使用代理的图片预加载var MyImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); var img = new Image; img.onload = function()&#123; imgNode.src = img.src; &#125; return &#123; setSrc: function(src)&#123; imgNode.src = 'loading.gif'; img.src = src; &#125; &#125;&#125;)();MyImage.setSrc('image.png'); 1234567891011121314151617181920212223// 使用代理的图片预加载 - 虚拟代理var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src)&#123; imgNode.src = src; &#125; &#125;;&#125;)();var proxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src)&#123; myImage.setSrc('loading.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('image.png'); 代理和本体接口的一致性 代理和本体接口的一致性(代理接手请求的过程对于用户来说是透明的) 1、用户可以放心的请求代理，他只关心是否能得到想要的结果。 2、在任何使用本地的地方都可以替换成使用代理 缓存代理123456789101112131415161718192021// 乘积函数var mult = function()&#123; var a = 1; for(var i = 0, len = arguments.length; i &lt; len; i++)&#123; a = a * arguments[i]; &#125; return a;&#125;// 加入缓存代理var proxMult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call(arguments,','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = mult.apply(this, arguments); &#125;&#125;)();proxMult(1,2,3,4,5);proxMult(1,2,3,4,5); 使用代理的意义 使用代理的意义 单一职责原则：一个类(通常包括对象和函数等)而言，应该仅有一个引起它变化的原因。如果对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。 面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。 在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放 - 封闭原则。如果五年后网速快到根本不需要预加载技术，我们可能希望把预加载图片的这段代码从MyImage对象里删掉，这个时候就不得不改动MyIage对象了。 在JavaScript开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便访问某个对象的时候，再编写代理也不迟。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESLint检查代码质量]]></title>
      <url>%2F2017%2F02%2F16%2FESLint%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F.html</url>
      <content type="text"><![CDATA[从接触js开始就想尝试ESLint， 但是一执行检查满屏的Error、惨绝人寰(a、a、a)、后放弃 为什么会有如此多的Error： 刚开始接触 ESLint 时觉得太难，是因为过太过于迷信权威。比如 Airbnb 公司的 JavaScript 风格，在 GitHub 上受到了很大的好评，其实我自己也非常认可这样的编码风格。但每个团队都会根据自己的的实际情况来定制不同的东西，我们并不能随便照搬过来。所以当使用eslint-config-airbnb这个配置进行 ESLint 检查时，满屏都是error和warning，从而觉得这东西根本没啥卵用。 直接使用eslint-config-airbnb这种某个公司高度定制化的配置直接使用eslint-config-airbnb这种某个公司高度定制化的配置，而不是eslint:recommended这样保守的。而且是直接用来检查整个项目好几十个 JS 文件，可想而知那是怎样的画面 ESLint是一个插件化的 JavaScript 代码检查工具，用于检查常见的 JS代码错误，也可以进行代码风格检查，可以根据自己的洗好指定一套ESLint配置项，让后应用于所编写的项目中，从而实现 辅助编码规范的执行，有效控制代码的质量 使用ESLint 通过npm安装： npm install -g eslint 通过 eslint —init 命令在当前目录下生成 .eslintrc.* 文件。如果没有 package.json文件的话，需要先创建一个这个文件，eslint会根据你的安装向导写入对应的插件到 devDependencies 里面 12"dependencies": &#123;&#125;,//生产环境"devDependencies": &#123;&#125;//开发环境 配置ESLint 通过配置文件： .eslingrc.* 或 package.json 中添加 eslintConfig 属性 配置的内容 环境：代码运行的环境，每个环境与预设了一些全局变量 全局变量：代码所运用到的全局变量 规则：规则的运用以及规则的等级 规则每条规则有3个等级： off、warn 、error off( 0 )：禁用这条规则 warn( 1 )：表示仅给出警告、并不会导致检查不通过 error( 2 )：错误、检查不通过 如果配置了 &quot;extends&quot;:&quot;eslint:recommended&quot;, 则 ESLint Rules页面 所有打钩的规则都会被生效（ 基础配置信息 ）。大多数时候，我们会根据自己个人或者团队的习惯，定制更多的规则，( 限定缩进2个空格和实用单引号的字符串等等 ) 可以写一套自己的配置项发布到NPM上的ESLint配置 模块名一般以 eslint-config- 为前缀。要是用这个配置，先止一下命令安装它： npm install eslint-config-shen 指定Parser的选项ESLint默认只支持ES5的语法，但你可以通过指定parser来支持检测ES6和JSX语法。具体是在 .eslintrc.* 文件中使用 parserOptions 属性。可以设置如下内容 ecmaVersion：可以设置3，5（默认）和6来代表ECMAScript的版本 sourceType：可以设置“script”（默认）或”module”如果你的代码采用模块化的方式 ecmaFeatures：设置features：globalReturn：在全局范围内允许使用return语句impliedStrict：如果ecmaVersion为5及以上，使用全局的 strict modejsx：使用JSX语法experimentalObjectRestSpread Parser：语法分析器。options：选择 指定环境 amd：定义 require() 和 define() 作为全局变量 12345"env": &#123; "browser": true, "node": true, 'jquery': true&#125;, 配置插件ESLint支持第三方插件的使用，在使用插件前需要通过npm来安装。在配置文件中使用plugins来设置插件名称。带有eslint-plugin-前缀的插件名称可以省略其前缀。如 123456&#123; "plugins": [ "plugin1", "eslint-plugin-plugin2" ]&#125; 注意：如果是使用的全局安装的ESLint的话，则只能使用全局安装的ESlint插件。而使用本地安装的ESLint则可以使用全局和本地安装的ESLint插件。 使用配置文件通过 .eslintrc.* 或 .eslintrc.json 文件方式，ESLint会自动寻找当前目录下的这两个文件，如果没有就想父级目录寻找，直到查询到根目录。这种方式比较有用，特别是需要针对不同的部分应用不同的规则。最里面的配置规则要比它的父级权限大。 ESLint支持如下几种格式的配置文件： JavaScript：使用 .eslintrc.js,通过exports一个包含所有规则的对象 JSON：使用 .eslintrc.json 来配置规则 package.json：在 package.json 中定义 eslintConfig 来设置规则 YAML Deprecated 如果当前目录下有多个配置格式的文件，则ESLint只会使用其中一个，顺序为： .eslintrc.js &gt; .eslintrc.yaml &gt; .eslintrc.yml &gt; .eslintrc.json &gt; .eslintrc &gt; package.json 默认情况下，我们不需要应用跨项目的配置规则，即使项目在目录上有父子关系，此时我们可以通过在 package.json 的 eslintConfig 或 .eslintrc.* 中设置 &quot;root&quot;: true 来静止ESLint继续想上级查找配置文件 123&#123; "root": true&#125; 项目级别的配置 目录下的 .eslintrc.* 或 package.json 继续在父级目录中查找的 .eslintrc 和 package.json 文件，直到出现 &quot;root&quot;: true 如果前两个都没有配置文件的话，就会用用户根目录下的 ~/.eslintrc 继承配置文件 如果你想继承某个特定的配置文件，可以使用 extends 属性，并且制定一个路径，可以是相对或绝对路径。可以继承多个文件，写在下面的配置规则会覆盖上面配置中对应的规则。 12345678910module.exports = &#123; "extends": [ "eslint":"recommended", "./node_modules/coding-standard/.eslintrc-es6" ], "rules": &#123; 'no-var': 'off', 'no-console': 'off' &#125;&#125;; 配置文件中的注释JSON和YAML配置文件都支持JavaScript格式注释， package.json 不支持注释 代码格式化、自动修复一些问题eslint test.js --fix 发布一个ESLint NPM管理包。。。 123456789101112131415161718192021222324module.exports = &#123; "root": true, "env": &#123; 'browser': true, 'es6': true, 'node': true, 'jquery': true &#125;, "extends": "eslint:recommended", "rules": &#123; 'no-var': 'off', 'no-console': 'off', // "indent": [ // "error", "tab" // ], // "linebreak-style": [ // "error", "unix" // ], // "quotes": [ // "error", "single" // ], // "semi": ["error", "always"] &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533module.exports = &#123; // 禁止ESLint继续向上级查找配置文件 "root": true, // 环境：预定以的全局变量 "env": &#123; 'browser': true, 'es6': true, 'node': true, 'jquery': true, 'amd': true, 'commonjs': true &#125;, // JavaScript 语言选项 "parserOptions": &#123; // ECMAScript 版本 "ecmaVersion": 6, "sourceType": "script", //module &#125;, "extends": "eslint:recommended", "rules": &#123; //////////////// // 警告 //////////////// // 强制使用有效的 JSDoc 注释 "valid-jsdoc": 1, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 "comma-dangle": [ 1, "never" ], // 禁止或强制在单行代码块中使用空格(禁用) "block-spacing": [ 1, "never" ], // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,"that"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 "consistent-this": [ 1, "that" ], // 强制使用一致的换行风格 "linebreak-style": [ 1, "unix" ], // 要求在注释周围有空行 ( 要求在块级注释之前有一空行) "lines-around-comment": [ 1, &#123; "beforeBlockComment": true &#125; ], // 强制 function 定义中最多允许的参数数量 "max-params": [ 1, 7 ], // 强制 function 块最多允许的的语句数量 "max-statements": [ 1, 200 ], // 要求方法链中每个调用都有一个换行符 "newline-per-chained-call": 1, // 要求使用 JSDoc 注释 "require-jsdoc": 1, // 强制一行的最大长度 "max-len": [ 1, 200 ], // 禁止在没有类型检查操作符的情况下与 null 进行比较 "no-eq-null": 1, // 禁止在全局范围内使用 var 和命名的 function 声明 "no-implicit-globals": 1, // 禁止在循环中出现 function 声明和表达式 "no-loop-func": 1, // 禁用魔术数字(3.14什么的用常量代替) "no-magic-numbers": [ 1, &#123; "ignore": [0, -1, 1] &#125; ], //////////////// // 禁止 //////////////// // 禁用 console "no-console": 0, // 禁止不必要的括号 //(a * b) + c;//报错 "no-extra-parens": 0, // 禁止直接使用 Object.prototypes 的内置属性 "no-prototype-builtins": 0, // 强制数组方法的回调函数中有 return 语句 "array-callback-return": 0, // 强制把变量的使用限制在其定义的作用域范围内 "block-scoped-var": 0, // 要求 return 语句要么总是指定返回的值，要么不指定 "consistent-return": 0, // 禁用 alert、confirm 和 prompt "no-alert": 0, // 禁止 if 语句中有 return 之后有 else "no-else-return": 0, // 禁用不必要的标签 "no-extra-label:": 0, // 禁止 this 关键字出现在类和类对象之外 "no-invalid-this": 0, // 禁止对 Function 对象使用 new 操作符 "no-new-func": 0, // 不允许对 function 的参数进行重新赋值 "no-param-reassign": 0, // 禁止使用短符号进行类型转换(!!fOO) "no-implicit-coercion": 0, // 禁用指定的通过 require 加载的模块 "no-return-assign": 0, // 禁止使用 javascript: url "no-script-url": 0, // 禁止出现未使用过的表达式 "no-unused-expressions": 0, // 禁用不必要的转义字符 "no-useless-escape": 0, // 禁用 void 操作符 "no-void": 0, // 禁止在注释中使用特定的警告术语 "no-warning-comments": 0, // 要求或禁止使用严格模式指令 "strict": 0, // 要求所有的 var 声明出现在它们所在的作用域顶部 "vars-on-top": 0, // 强制使用命名的 function 表达式 "func-names": 0, // 禁止使用指定的标识符 "id-blacklist": 0, // 强制标识符的最新和最大长度 "id-length": 0, // 要求标识符匹配一个指定的正则表达式 "id-match": 0, // 强制在 JSX 属性中一致地使用双引号或单引号 "jsx-quotes": 0, // 要求或禁止 var 声明中的初始化(初值) "init-declarations": 0, // 不允许 catch 子句的参数与外层作用域中的变量同名 "no-catch-shadow": 0, // 禁用特定的全局变量 "no-restricted-globals": 0, // 禁止 var 声明 与外层作用域的变量同名 "no-shadow": 0, // 禁止将 undefined 作为标识符 "no-undefined": 0, // 强制一致地使用函数声明或函数表达式，方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, "declaration"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, "expression"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, "declaration", &#123; "allowArrowFunctions": true &#125;] "func-style": 0, // 强制最大行数 "max-lines": 0, // 强制每一行中所允许的最大语句数量 "max-statements-per-line": 0, // 禁用按位运算符 "no-bitwise": 0, // 不允许在变量定义之前使用它们 "no-use-before-define": 0, // 要求或禁止 var 声明语句后有一行空行 "newline-after-var": 0, // 要求 return 语句之前有一空行 "newline-before-return": 0, // 禁用 continue 语句 "no-continue": 0, // 禁止在代码行后使用内联注释 "no-inline-comments": 0, // 禁止 if 作为唯一的语句出现在 else 语句中 "no-lonely-if": 0, // 禁止混合使用不同的操作符 "no-mixed-operators": 0, // 不允许使用三元操作符 "no-ternary": 0, // 禁止使用特定的语法 "no-restricted-syntax": 0, // 禁止标识符中有悬空下划线_bar "no-underscore-dangle": 0, // 不允许否定的表达式 "no-negated-condition": 0, // 不允许使用嵌套的三元表达式 "no-nested-ternary": 0, // 禁止使用一元操作符 ++ 和 -- "no-plusplus": 0, // 要求或禁止在 var 声明周围换行 "one-var-declaration-per-line": 0, // 要求或禁止在可能的情况下要求使用简化的赋值操作符 "operator-assignment": 0, // 禁止属性前有空白 "no-whitespace-before-property": 0, // 强制花括号内换行符的一致性 "object-curly-newline": 0, // 强制在花括号中使用一致的空格 "object-curly-spacing": 0, // 强制将对象的属性放在不同的行上 "object-property-newline": 0, // 要求或禁止块内填充 "padded-blocks": 0, // 要求对象字面量属性名称用引号括起来 "quote-props": 0, // 强制分号之前和之后使用一致的空格 "semi-spacing": 0, // 要求同一个声明块中的变量按顺序排列 "sort-vars": 0, // 要求或禁止 Unicode BOM "unicode-bom": 0, // 要求正则表达式被括号括起来 "wrap-regex": 0, //////////////// // 错误 //////////////// // 禁止条件表达式中出现赋值操作符 "no-cond-assign": 2, // 禁止在条件中使用常量表达式 // if (false) &#123; // doSomethingUnfinished(); // &#125; //cuowu "no-constant-condition": 2, // 禁止在正则表达式中使用控制字符 ：new RegExp("\x1f") "no-control-regex": 2, // 禁用 debugger "no-debugger": 2, // 禁止 function 定义中出现重名参数 "no-dupe-args": 2, // 禁止对象字面量中出现重复的 key "no-dupe-keys": 2, // 禁止重复的 case 标签 "no-duplicate-case": 2, // 禁止空语句块 "no-empty": 2, // 禁止在正则表达式中使用空字符集 (/^abc[]/) "no-empty-character-class": 2, // 禁止对 catch 子句的参数重新赋值 "no-ex-assign": 2, // 禁止不必要的布尔转换 "no-extra-boolean-cast": 2, // 禁止不必要的分号 "no-extra-semi": 2, // 禁止对 function 声明重新赋值 "no-func-assign": 2, // 禁止在嵌套的块中出现 function 或 var 声明 "no-inner-declarations": [ 2, "functions" ], // 禁止 RegExp 构造函数中无效的正则表达式字符串 "no-invalid-regexp": 2, // 禁止在字符串和注释之外不规则的空白 "no-irregular-whitespace": 2, // 禁止在 in 表达式中出现否定的左操作数 "no-negated-in-lhs": 2, // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math(); "no-obj-calls": 2, // 禁止正则表达式字面量中出现多个空格 "no-regex-spaces": 2, // 禁用稀疏数组 "no-sparse-arrays": 2, // 禁止出现令人困惑的多行表达式 "no-unexpected-multiline": 2, // 禁止在return、throw、continue 和 break语句之后出现不可达代码 /* function foo() &#123; return true; console.log("done"); &#125;//错误 */ "no-unreachable": 2, // 要求使用 isNaN() 检查 NaN "use-isnan": 2, // 强制 typeof 表达式与有效的字符串进行比较 // typeof foo === "undefimed" 错误 "valid-typeof": 2, // 限制圈复杂度，也就是类似if else能连续接多少个 "complexity": [ 2, 9 ], // 强制所有控制语句使用一致的括号风格 "curly": [ 2, "all" ], // 要求 for-in 循环中有一个 if 语句 "guard-for-in": 2, // 禁用 arguments.caller 或 arguments.callee "no-caller": 2, // 定义对象的set存取器属性时，强制定义get "accessor-pairs": 2, // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告 "default-case": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 "dot-location": [ 2, "property" ], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;"allowKeywords": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;"allowPattern": "^[a-z]+(_[a-z]+)+$"&#125;] "dot-notation": [ 2, &#123; "allowKeywords": false &#125; ], // 使用 === 替代 == allow-null允许null和undefined== "eqeqeq": [ 2, "allow-null" ], // 不允许在 case 子句中使用词法声明 "no-case-declarations": 2, // 禁止除法操作符显式的出现在正则表达式开始的位置 "no-div-regex": 2, // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。 "no-empty-function": 2, // 禁止使用空解构模式no-empty-pattern "no-empty-pattern": 2, // 禁用 eval() "no-eval": 2, // 禁止扩展原生类型 "no-extend-native": 2, // 禁止不必要的 .bind() 调用 "no-extra-bind": 2, // 禁止 case 语句落空 "no-fallthrough": 2, // 禁止数字字面量中使用前导和末尾小数点 "no-floating-decimal": 2, // 禁止使用类似 eval() 的方法 "no-implied-eval": 2, // 禁用 __iterator__ 属性 "no-iterator": 2, // 禁用标签语句 "no-labels": 2, // 禁用不必要的嵌套块 "no-lone-blocks": 2, // 禁止使用多个空格 "no-multi-spaces": 2, // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串 "no-multi-str": 2, // 禁止对原生对象赋值 "no-native-reassign": 2, // 禁止在非赋值或条件语句中使用 new 操作符 "no-new": 2, // 禁止对 String，Number 和 Boolean 使用 new 操作符 "no-new-wrappers": 2, // 禁用八进制字面量 "no-octal": 2, // 禁止在字符串中使用八进制转义序列 "no-octal-escape": 2, // 禁用 __proto__ 属性 "no-proto": 2, // 禁止使用 var 多次声明同一变量 "no-redeclare": 2, // 禁止自我赋值 "no-self-assign": 2, // 禁止自身比较 "no-self-compare": 2, // 禁用逗号操作符 "no-sequences": 2, // 禁止抛出非异常字面量 "no-throw-literal": 2, // 禁用一成不变的循环条件 "no-unmodified-loop-condition": 2, // 禁用未使用过的标签 "no-unused-labels": 2, // 禁止不必要的 .call() 和 .apply() "no-useless-call": 2, // 禁止不必要的字符串字面量或模板字面量的连接 "no-useless-concat": 2, // 禁用 with 语句 "no-with": 2, // 强制在parseInt()使用基数参数 "radix": 2, // 要求 IIFE 使用括号括起来 "wrap-iife": [ 2, "any" ], // 要求或禁止 “Yoda” 条件 "yoda": [ 2, "never" ], // 禁止删除变量 "no-delete-var": 2, // 不允许标签与变量同名 "no-label-var": 2, // 禁止覆盖受限制的标识符 "no-shadow-restricted-names": 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 "no-undef": 2, // 禁止将变量初始化为 undefined "no-undef-init": 2, // 禁止出现未使用过的变量 "no-unused-vars": [ 2, &#123; "vars": "all", "args": "none" &#125; ], // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 "array-bracket-spacing": [ 2, "never" ], //强制使用一致的缩进 第二个参数为 "tab" 时，会使用tab， // if while function 后面的&#123;必须与if在同一行，java风格。 "brace-style": [ 2, "1tbs", &#123; "allowSingleLine": true &#125; ], // 双峰驼命名格式 "camelcase": 2, // 控制逗号前后的空格 "comma-spacing": [ 2, &#123; "before": false, "after": true &#125; ], // 控制逗号在行尾出现还是在行首出现 (默认行尾) // http://eslint.org/docs/rules/comma-style "comma-style": [ 2, "last" ], //"SwitchCase" (默认：0) 强制 switch 语句中的 case 子句的缩进水平 // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always "computed-property-spacing": [ 2, "never" ], // 文件末尾强制换行 "eol-last": 2, "indent": [ 2, 4, &#123; "SwitchCase": 1 &#125; ], // 强制在对象字面量的属性中键和值之间使用一致的间距 "key-spacing": [ 2, &#123; "beforeColon": false, "afterColon": true &#125; ], // 强制回调函数最大嵌套深度 5层 "max-nested-callbacks": [ 1, 5 ], // 强制在关键字前后使用一致的空格 (前后腰需要) "keyword-spacing": 2, // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。） "new-cap": [ 2, &#123; "newIsCap": true, "capIsNew": false &#125; ], // 要求调用无参构造函数时有圆括号 "new-parens": 2, // 禁止使用 Array 构造函数 "no-array-constructor": 2, // 不允许空格和 tab 混合缩进 "no-mixed-spaces-and-tabs": 2, // 不允许多个空行 "no-multiple-empty-lines": [ 2, &#123; "max": 2 &#125; ], // 禁止使用 Object 的构造函数 "no-new-object": 2, // 禁止 function 标识符和括号之间出现空格 "no-spaced-func": 2, // 禁用行尾空格 "no-trailing-spaces": 2, // 禁止可以在有更简单的可替代的表达式时使用三元操作符 "no-unneeded-ternary": 2, // 强制函数中的变量要么一起声明要么分开声明 "one-var": [ 2, &#123; "initialized": "never" &#125; ], // 强制操作符使用一致的换行符 "operator-linebreak": [ 2, "after", &#123; "overrides": &#123; "?": "before", ":": "before" &#125; &#125; ], // 强制使用一致的反勾号、双引号或单引号 "quotes": [ 2, "single", "avoid-escape" ], // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，） "semi": [ 2, "always" ], // 强制在块之前使用一致的空格 "space-before-blocks": [ 2, "always" ], // 强制在 function的左括号之前使用一致的空格 "space-before-function-paren": [ 2, "always" ], // 强制在圆括号内使用一致的空格 "space-in-parens": [ 2, "never" ], // 要求操作符周围有空格 "space-infix-ops": 2, // 强制在一元操作符前后使用一致的空格 "space-unary-ops": [ 2, &#123; "words": true, "nonwords": false &#125; ], // 强制在注释中 // 或 /* 使用一致的空格 "spaced-comment": [ 2, "always", &#123; "markers": [ "global", "globals", "eslint", "eslint-disable", "*package", "!" ] &#125; ] &#125;&#125;; 参考1：老雷篇(Node.js实战) 参考2：细节篇 ESLinit中文版文档 ESLinit中文版文档 - 规则配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[永远不要对人怀有恨意或怨言]]></title>
      <url>%2F2017%2F02%2F09%2F%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%AF%B9%E4%BA%BA%E6%80%80%E6%9C%89%E6%81%A8%E6%84%8F%E6%88%96%E6%80%A8%E8%A8%80.html</url>
      <content type="text"><![CDATA[仇恨和怨意，会降低大脑灵活性，导致智力严重缩水，偏离自我的发展轨道。 善未必聪明，但坏必蠢 不要然自己成为蠢人，因此千万不可怨恨 ( 虐你千百遍，依旧带其如初恋 )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-策略模式(2)]]></title>
      <url>%2F2017%2F02%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(2).html</url>
      <content type="text"><![CDATA[策略模式( Strategy )：将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化 策略模式( Strategy )：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换 使用策略模式计算奖金 年终奖是根据员工的工资基数和年底绩效来发放的 绩效S的人有4倍工资、绩效A的人有3倍工资，绩效B的人有2倍工资 最初的代码实现(1)1234567891011121314// calculate:计算，bonus:奖金，salary:薪水，performance:工作情况var calculateBonus = function(performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return salary * 4; &#125; if (performanceLevel === 'A') &#123; return salary * 3 &#125; if (performanceLevel === 'B') &#123; return salary * 2 &#125;&#125;calculateBonus('S',25000);calculateBonus('B',9000); 非常简单的代码，但是存在的问题也显而易见。 calculateBonus 函数比较庞大，包含了很多if-else语句，这些语 句需要覆盖所有的逻辑分支 calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S的奖金修改为5，那我们必须深入 calculateBonus 函数的内部实现，这违反 开放-封闭 原则 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择只有复制和粘贴 使用组合函数重构代码(2)123456789101112131415161718192021var performanceS = function(salary) &#123; return salary * 4;&#125;var performanceA = function(salary) &#123; return salary * 3;&#125;var performanceB = function(salary) &#123; return salary * 2;&#125;var calculateBonus = function(performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return performanceS(salary); &#125; if (performanceLevel === 'A') &#123; return performanceS(salary); &#125; if (performanceLevel === 'B') &#123; return performanceS(salary); &#125;&#125;calculateBonus('A', 18000); 组容易想到重构代码的办法就是：使用组合函数来重构代码 把各种算法封装到一个个的小函数里，这些小函数有这良好的命名规范、一目了然地知道它对应着那种算法，他们可以被复用在程序的其他地方 程序确实得到了一些非常有限的改善，但是依然没有解决最重要的问题 calculateBonus 函数有可能越来越大 协同变化的时候缺乏弹性 将不变的部分 和 变化的部分 隔开是每个设计模式的主题 策略模式的目的就是将算法的使用与算法的实现分离开来 一个基于策略模式的程序至少由两部分组成。 一组策略类，策略类封装了具体的算法，并负责具体的计算过程 环境类Context，Context接受客户的请求，随后把请求委托給摸一个策略类。要做到这点，说明Context中药维持对某个策略对象的引用 策略模式重构代码(3-1)123456789101112131415161718// JavaScript版本的策略模式// 策略模式指的是定义一系列的算法，并且把他们封装起来。var strategies = &#123; "S": function(salary) &#123; return salary * 4; &#125;, "A": function(salary) &#123; return salary * 3; &#125;, "B": function(salary) &#123; return salary * 2; &#125;&#125;var calculateBonus = function(level, salary) &#123; return strategies[level](salary);&#125;console.log(calculateBonus('S', 30000));console.log(calculateBonus('A', 20000)); 通过使用策略模式重构代码，消除了原程序中大片的条件分支语句。 所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算过奖金的能力，而是把这个职责委托給了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。 当我们对这些策略对象发出”计算奖金”的请求时，它们会放回各自不同的计算结果，这正是对象多态性的体现，也是”它们可以相互替换”的目的，替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果 策略模式 - 表单校验 将用户输入的数据交給后台之前，常常要做一些前端力所能及的校验工作，比如注册的时候需要校验是否填写用户名，密码的长度是否符合规定。。 这样是为了避免因为提交不合法数据而带来的不必要的网络开销。 在点击提交按钮之前，有几条校验的逻辑 姓名、手机号、验证码不能为空 手机号、验证码 非错误 手机号必须符合格式 输入框需过滤特殊字符 - 防SQL注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# validator:校验# strategy:策略// 第一步：把校验逻辑都封装成 '策略对象'var strategies = &#123; isNonEmpty: function(value, errorMsg) &#123; if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function(value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function(value, errorMsg) &#123; if (!/^1[3|5|8][0-9]&#123;9&#125;9$/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;;// 第二步：实现Validator类var Validator = function()&#123; this.cache = [];// 保存校验规则&#125;;// 通过validator.add()方法向validator对象中添加一些校验规则Validator.prototype.add = function( Dom, Rule, ErrorMsg)&#123; var ary = Rule.split(':');// 把strategy和参数值分开minLength:9 this.cache.push(function()&#123;// 把校验的步骤用空函数包装起来，并且放入this.cache中、在开始校验的时候进行循环调用 // 用户挑选的 strategy var strategy = ary.shift(); // 把input中的value值添加进参数列表 // 调用:strategies.minLength(value, length, errorMsg); ary.unshift(Dom.value); // 把errorMsg添加进参数列表 ary.push(errorMsg); // 调用封装的策略对象 // Dom替换Function类里this对象 // ary将作为参数(arguments)传递给Function return strategies[strategy].apply(Dom, ary); &#125;);&#125;// 通过validator.start()启动校验Validator.prototype.start = function()&#123; // validatorFunc 一个独立变量、循环之后执行 // 当前for循环的 结束界点是 this.cache取值为undefind的时候 for(var i=0; validatorFunc; validatorFunc=this.cache[i++])&#123; var msg = validatorFunc(); if(msg)&#123; return msg &#125; &#125;&#125;;// 第三步：执行步骤 - 用户向Validator类发送请求var validataFunc = function()&#123; var validator = new Validator();// 创建validator对象 // 向this.cache中添加校验规则 validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空~'); validator.add(registerForm.password, 'minLength:6', '密码长度不能少于6位~'); validator.add(registerForm.phoneNumber, 'isMobile', '手机号格式不正确~'); // 获得校验结果 var errorMsg = validator.start(); return errorMsg;// 返回校验结果：strategies中的错误返回值&#125;// 第四步：提交表单var registerForm = document.getElementById('registerForm');registerForm.onsubmit = function()&#123; // 如果errorMsg有确切的返回值，说明未通过校验 var errorMsg = validataFunc(); if(errorMsg)&#123; alert(errorMsg); return false;// 阻止表单提交 &#125;&#125; 当前的校验方法中用到了 原型链模式 策略模式 在 validator.add()方法内: apply(Dom, ary); 改变当前value的Dom的this值，改变this的同时传递this.cache数组内的参数(arguments) 并且执行 在 validator.add()方法内:在 this.cache.push() 中使用闭包 在 validator.start()方法内：for循环的结束节点用的是数组的空值 undefined 进行判定的，初始条件是一个不为false的函数值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式 - 单例模式(1)]]></title>
      <url>%2F2017%2F02%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1).html</url>
      <content type="text"><![CDATA[单例模式( Singleton )：确保只有一个实例，并提供全局访问 在 JavaScript 开发中，我们经常会把全局变量当做单例来使用 var a = {}; 命名空间( namespace )的管理 命名空间：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所有不同的人定义的变量使用的单词名称很有可能重复，此时就需要使用命名空间来约束每个人定义的变量来解决这类问题。 1234567891011var BusinessGoInit = &#123; getServerTime: function() &#123; // 获取服务器时间戳 &#125;, isUserVip: function() &#123; // 是否为会员 &#125;, toShortUrl: function() &#123; // 短链接 &#125;&#125; 模块分明 通过单例模式来管理代码库的各个模块 123456789101112131415161718var A = &#123; Util: &#123; util_method1: function() &#123;&#125;, util_method2: function() &#123;&#125; &#125;, Tool: &#123; tool_method1: function() &#123;&#125;, tool_method2: function() &#123;&#125; &#125;, Ajax: &#123; get: function() &#123;&#125;, post: function() &#123;&#125; &#125;, others: &#123; xxx: function() &#123;&#125;, yyy: function() &#123;&#125; &#125;&#125; 管理静态变量123456789101112131415161718var Conf = (function() &#123; // 私有变量 var config = &#123; MAX_NUM: 100, MIN_NUM: 1, COUNT: 1000 &#125; // 返回取值器对象 return &#123; // 通过取值器方法访问静态变量 get: function(name) &#123; return config[name] ? config[name] : null; &#125; &#125;&#125;)();var count = Conf.get('COUNT');console.log(count); // 1000// 静态变量只能访问，不能修改。并且无创建后就能使用 惰性单例 惰性单例：在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用。 案例：登陆窗、在一个项目里登陆窗总是唯一的，不可能同时存在两个登陆窗口的情况 ( 两种解决方案 ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 解决方案一：// 1、在页面加载完成的时候便创建好这个div弹窗// 2、弹窗一开始肯定是隐藏的姿态// 3、用户点击登陆按钮，显示弹窗var loginLayer = (function()&#123; var oDiv = document.createElement('div'); oDiv.innerHTML = '我是登录框'; oDiv.style.display = 'none'; document.body.appendChild(oDiv); return oDiv;&#125;)();document.onclick = function()&#123; loginLayer.style.display = 'block';&#125;// 这种方式有一个问题，也许我们进入当前项目根本不需要登陆操作// 应为登陆窗口总是在一开始就被创建好，那么就会白白浪费掉一些DOM节点// 解决方案一：改进1var createLoginLayer = function()&#123; var oDiv = document.createElement('div'); oDiv.innerHTML = '我是登录框'; oDiv.style.display = 'none'; document.body.appendChild(oDiv); return oDiv;&#125;document.onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;// 改进方案虽然实现了惰性的目的，但是失去了单例的效果。// 当我们每次点击登陆按钮的时候，都会创建一个新的登录弹窗div// 虽然我们可以在点击弹出上的关闭按钮时，把这个弹出从页面中删除// 但这样频繁地创建和删除节点明显是不合理的，也是不必要的// 解决方案一：改进2// 可以使用一个变量来判断是否已经创建过登录弹出了var createLoginLayer = (function()&#123; var div = null; return function()&#123; if(!div)&#123; div = document.createElement('div'); div.innerHTML = '我是登录弹出'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;// 这样写就完成了一个可用的惰性单例，但还有一些问题// 创建对象和管理单例都放在createLoginLayer对象内部// 复用性 - 若下次创建iframe或者script，就必须如法炮制// 把createLoginLayer函数几乎照抄一遍 12345678910111213141516171819202122232425262728293031323334// 解决方案二：按需加载// 我们把如何管理单例的逻辑从原来的代码中抽离出来// 封装在getSingle函数内部，创建对象的方法fn被当做参数动态的传入var getSingle = function(fn)&#123; var result; return function()&#123; // return result || (result = fn()); return result || (result = fn.apply(this,arguments)); &#125;&#125;var createLoginLayer = function()&#123; var oDiv = document.createElement('div'); oDiv.innerHTML = '我是登录框'; oDiv.style.display = 'none'; document.body.appendChild(oDiv); return oDiv;&#125;var createSingleLoginLayer = getSingle(createLoginLayer);document.onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;// 我们把创建实例对象的职责 和 管理单例的职责分别放置在两个方法里面// 两个方法可以独立变化而互不影响，当他们链接在一起，就完成了创建唯一实例对象的功能// 再试试创建唯一的iframe用于动态加载第三方页面var createSingleIframe = getSingle(function()&#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;&#125;);document.onclick = function()&#123; var loginLayer = createSingleIframe(); loginLayer.src = 'http://hao123.com'&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[this深入理解]]></title>
      <url>%2F2016%2F12%2F31%2Fthis%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html</url>
      <content type="text"><![CDATA[回想起这6个月的工作经历、业务做了不少，熟练度直线上升。然而归纳却寥寥无几，这让我再次抓起了我当初简历博客的初衷，不花时间精力去总结，平时业务上用到的零散的知识就很难形成体系。善于归纳总结：如果不善于归纳总结，每次做完项目就结束了，进入循环，那么永远是士兵，不要总是讲一些口号，喊口号的人可以当主持人，但是不能当将军。不归纳就不能前进，不前进就永远在原地踏步。认识一步步前进的，只要一小步一小步地前进，过几年当你汇总总结时，就会发现你前进了一大步。 This、call、apply This：JavaScript的this总是指向一个对象。 而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 在理解 this 是什么❓首先必须要找到”调用位置“，然后判断符合那种规则。 当一个函数被调用时，会创建一个”执行上下文环境”： 包含函数在哪里被调用 ( 调用栈 ) 。 函数调用方法。 传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。 This指向大致可以分为如下四类： 作为对象的方法调用。 作为普通函数调用。 构造器调用 Function.prototype.call 和 Function.prototype.apply 调用 1、作为对象的方法调用 当函数作为对象的方法被调用时, this 指向该对象 12345678// 当函数作为对象的方法被调用时、this指向该对象var obj = &#123; a:1, getA: function()&#123; alert(this === obj);//true alert(this.a);//1 &#125;&#125; 1-1、隐式绑定 另一条需要考虑的规则是： 调用位置是 否有上下文 — “对象” ，或者说 是否被某个对象拥有( 包含 ) 123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;obj.foo();## 1：无论是直接在obj中定义、还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象。## 2：然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象"拥有"或者"包含"了它。## 3：无论我们如何称呼这个模式，当foo()被调用时，它的落脚点确实指向obj对象。当函数引用有上下文对象时，"隐式绑定"规则会把函数调用中的"this"绑定到这个上下文对象。因为调用foo()时this被绑定到obj，所以this.a和obj.a是一样的## 4：对象属性引用链中，只有最后一层( 最顶层 )会影响到调用位置 1-2、隐式绑定丢失 最常见的隐式绑定问题： 被”隐式绑定”的函数会丢失绑定对象，也就是说它会应用”默认绑定”，从而把this绑定到全局对象或者”undefined”上，取决于是否是”严格模式” 解决办法：使用”显示绑定”的方案 call(...)和apply(…) 的”硬绑定”模式 123456789101112131415161718192021222324252627282930// 丢失案例一：堆内存地址的引用function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;var bar = obj.foo;var a = "oops,global";bar();// oops,global## 虽然bar是obj.foo的一个引用。## 但是实际上，它引用的是foo函数本身,是foo函数在堆内存空间的地址(复制的是指针的指向)## 本质上：bar() == foo();## 因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。// 丢失案例二：非常常见并且非常出乎意料的情况(参数传递)function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;var obj = &#123; a:2, foo:foo&#125;var a = "oops,global";doFoo(obj.foo);## 参数传递其实"就是"一种隐式赋值，因此我们传入函数时也会被隐式赋值。 引用类型参数传递问题 引用类型：引用类型传递的是指针的方向 12345678function setName(obj)&#123; obj.name = 'aaa'; return obj;&#125;var person = new Object();person.name = 'bbb';var newPerson = setName(person);console.log(person.name + ' || ' + newPerson.name); http://www.cnblogs.com/zareb/p/5699571.html 12345678910111213function setName(obj) &#123; obj.name = 'aaa'; var obj = new Object(); // 如果是按引用传递的,此处传参进来obj应该被重新引用新的内存单元 obj.name = 'ccc'; return obj;&#125;var person = new Object(); person.name = 'bbb';var newPerson = setName(person);console.log(person.name);console.log(newPerson.name); 2、作为普通函数调用 ( this - 默认绑定 ) 当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。 123456789101112131415161718192021222324252627282930// 使用普通函数时、其内的this总是指向window// 在代码中，getName()是直接使用不带任何修饰的函数引用进行调用的。因此只能使用"默认绑定"，无法应用其他规则。// 如果是严格模式( strict mode ),那么全局对象将无法使用默认规则，因此this会绑定到"undefined"上// 案例一：window.name = 'globalName';var getName = function()&#123; return this.name;&#125;console.log(getName());//globalName// 案例二：引用getName在堆内存中的地址window.name = 'globalName';var myObject = &#123; name:'ntscshen', getName:function()&#123; return this.name; &#125;&#125;var myName = myObject.getName;console.log(myName());// 案例三：在事件函数内部、有一个局部的方法。此方法被调用时，方法内部的this指向了windowdocument.getElementById('div1').onclick = function()&#123; console.log(this.id);// 'div1' //var _this = this;// 简单的解决方案 var callBack = function()&#123; //console.log(_this.id);// 'div1' console.log(this.id);// 'window' &#125; callBack();&#125;## 没当你想要把this和"词法"作用域的查找混合使用时，一定要提醒自己，这是无法实现的。 3、构造器调用4、 Function.prototype.call 和 Function.prototype.apply4-1：硬绑定 硬绑定的典型应用场景就是：创建一个包裹函数，传入所有的参数并返回接收到的所有值。 1234567891011121314151617181920212223242526// 案例一：function foo()&#123; console.log(this.a);&#125;var obj = &#123;a:2&#125;var bar = function()&#123; foo.call(obj);&#125;;bar();setTimeout(bar,100);bar.call(window);// 我们首先创建了函数bar()，并在它的内部手动调用了foo.call(obj),因此强制把foo的this绑定到了obj。无论之后如何调用函数bar，它总会手动在obj上调用foo。这种绑定是一种显示的强制绑定，因此称之为"硬绑定"// 案例二：function foo()&#123; console.log(this.a,something); return this.a + something;&#125;function bind(fn, obj)&#123; return function()&#123; return fn.apply(obj, arguments); &#125;;&#125;var obj = &#123;a:2&#125;;var b = bar(3);console.log(b);// 由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind,它的用法如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机号码中间部分替换成星号]]></title>
      <url>%2F2016%2F12%2F07%2F%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%AD%E9%97%B4%E9%83%A8%E5%88%86%E6%9B%BF%E6%8D%A2%E6%88%90%E6%98%9F%E5%8F%B7.html</url>
      <content type="text"><![CDATA[手机号中间4未数字使用星号替换 字符串截取 正则 字符串截取12345678910// 字符串截取 + 拼接'18500009973'.substr(0, 3) + '****' + '18500009973'.substr(7, 11);// 优化:确保输入的是字符串类型function formatPhone(phone) &#123; if (typeof phone == 'number')&#123; phone = phone.toString(); &#125; return phone.substr(0, 3) + '****' + phone.substr(7, 11);&#125;// 什么❓您不知道toString()是干什么的❓请看最底部 正则12345678function formatPhone(phone) &#123; if (typeof phone == 'number')&#123; phone = phone.toString(); &#125; return phone.replace(/(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)/, '$1****$2');&#125;// 匹配前面三个数字，讲匹配的值給$1,然后匹配中间4个数字，再匹配最后4个数字給$2// 什么❓您不会正则❓好吧！我也只会一点点 JavaScript toString()函数详解toString() 函数用于将当前对象以字符串的形式放回。 由于该方法属于 Object 对象，因此所有的对象都”继承“了 Object 的对象实例，所有的的实例对象都可以使用该方法、所有主流浏览器均支持该函数 JavaScript的许多内置对象都重写了该函数、以实现更适合自身的功能需求 类型 描述 Number 返回数值的字符串表示。(可以指定转换的 进制 ) Number.toString详细说明地址 Boolean 如果布尔值是true，则返回”true”,否则放回”false” Array 将Array的每个元素转换为字符串，并将它们以此连接起来，两个元素之间用英文逗号作为分隔符进行拼接 Date 返回日期的文本表示 Error 返回一个包含相关错误信息的字符串。 Object(默认) 返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。 Function 返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }” 实例:console 12345678910111213141516171819// 数组var array = ["ntscshen",true,"哈哈",99];array["ntscshen", true, "哈哈", 99]array.toString()"ntscshen,true,哈哈,99"// 布尔var bool = true;booltruebool.toString()"true"// 日期var date = new Date;dateWed Dec 07 2016 14:44:42 GMT+0800 (CST)date.toString()"Wed Dec 07 2016 14:44:42 GMT+0800 (CST)"// 数字var num = 12;document.writeIn(num.toString());// 什么❓您不知道writeIn❓那您知道write吗❓知道它们之间的区别吗❓知道如何在console打印内容吗❓知道打印的几种方式吗❓ write和writeIn document.write(&#39;hello word&#39;) 方法可向文档写入 HTML 表达式或 JavaScript 代码。 主要用于简单的打印内容到页面上 writeIn() 区别于 write() 的地方就是、 writeIn() 在末尾加了一个空格 console console.log() 向web控制台输出一条消息 (输出普通信息) console.dir() 向web控制台打印出该对象的所有属性和属性值，这个方法是我经常使用的 不知道比for in方便了多少 console.debug() console.log方法的别称，使用方法可以参考Console.log() console.warn() 输出警告信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webPlayer使用方法总结]]></title>
      <url>%2F2016%2F12%2F02%2FwebPlayer%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC] webPlayer 使用方法的一些总结 ( 建议先仔细阅读WebPlayerSDK点播.pdf和 WebPlayerSDK直播.pdf ) 点播播放器相关 文档中给出的 playId() 方法在页面只有一个点播播放器的时候可以正常使用，但当页面中有直播播放器时再次调用点播播放器的 playId() 方法就会失效，页面不会报错代码也会执行，只是执行完毕后没有出现预期的效果。初步猜测是因为其他播放器对这个功能造成了影响。解决方法是，重新创建一个播放器覆盖原有播放器。 当点播播放器中的视频是仅会员可看时，未登录用户点击此视频时播放器内部会提示用户登陆，此时要想实现登陆操作需要在点播播放器的页面接口集合 ( interface对象 ) 中传入 123openLoginDialog :function()&#123; verifyUserloginStatus();&#125; 当点播播放器中的视频是仅会员可看时，已登陆的非会员用户点击此视频时，播放器内部会提示用户开通会员，pc页面点击此按钮可以正常跳转到支付页面；m站页面点击此按钮无效，需要用事件委托的形式给开通会员按钮绑定跳转到支付页面的事件； PC页面中当点播播放器中的视频是仅会员可看时，用户中途登陆是会员的账户时播放器不会刷新（有的仅会员可看视频可以免费看前6分钟，所以存在中途登陆的情况），会依然提示他购买会员。调用播放器的 loginStateChange() 方法并未能解决问题，解决办法是 12345678910//监听登录状态 切换时触发$(function () &#123; LEPass.onStatusChange(function (type, userInfo) &#123; if (type == "signIn" ) &#123; ($(".na-drama-list").find(".playing").find("a").data("pid")) &#123; dianboPlayer($(".na-drama-list").find(".playing").find("a").data("pid")); &#125; &#125; &#125;);&#125;); （找到当前正在播放视频的id，利用此id重新创建播放器或者将id传入到 playId() 方法中，具体怎么操作需要看当前的代码结构）；m站页面没有此问题，因为只要登陆状态发生改变m站页面会自动强制刷新。 关于点播播放器续播的问题可以调用播放器的onPlayerVideoComplete事件回调 12345onPlayerVideoComplete: function () &#123; return &#123; status: 'playerContinue' &#125;&#125; 直播播放器相关直播分为“直播中”、“未开始”、“已结束”三种状态，其中要注意已结束的直播视频（也就是“回看”视频），从后台取出来的回看视频数据一般会带有一个名为 recordingId 的参数，但是有的原本正在直播中视频在刚刚结束的时候虽然已经变成了回看视频，但是并未带有 recordingId 参数。所以，对于回看视频： 如果取到recordingId参数就将recordingId传入到点播播放器； 如果取不到recordingId参数就将原本的视频id传入直播播放器。 一些共同的问题总结 关于播放器黑边，如果视频的比例全部一样，那么只要保证播放器盒子的宽高比和视频的一致就没有黑边了；如果视频的比例不一致，请尽可能将播放器的宽高调到一个合适的比例以保证黑边在所有视频中都尽可能小。 目前已知直播播放器会影响到点播播放器的 playId() 方法，由于本次项目经验有限，关于播放器之间的相互影响以及其他经验还需要屏幕外的你在未来的项目中进行总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[需求文档]]></title>
      <url>%2F2016%2F11%2F28%2F%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3.html</url>
      <content type="text"><![CDATA[需求文档 无论是正式的产品需求或是Demo需求( 必须要出产品需求 ) 基于对当前产品需求的了解之后 - 才能运用对应的技术站进行开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac上网络抓包Charles]]></title>
      <url>%2F2016%2F11%2F19%2FMac%E4%B8%8A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Charles.html</url>
      <content type="text"><![CDATA[抓包？就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。 为什么调试配置Host？ 我们知道在网络上访问网站，要首先通过DNS服务器把网络域名（www.XXXX.com）解析成61.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而Hosts文件就能提高解析效率。 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。 对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。 Charles Mac下常用的网络封包截取工具(免费30天 - 试用期过后建议购买正版) Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析 Charles主要功能 截取Http和Https网络封包。 支持重发网络请求，方便前后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟满网速网络 安装步骤下载好Charles - 打开下载包( .dmg后缀的文件 )后将Charles拖到Application目录下即可。 启动Charles后、第一次Charles会请求您给它设置系统代理的权限。图例如下！ 源： 译： Firefox代理服务器配置 源： 译： 在Firefox中打开 https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/ 源： 译： 这样在Firefox可以抓包Proxy -&gt; Mozilla Firefox Proxy 将Charles设置成系统代理Charles主界面 Structure：结构( 视图将网络请求按访问的域名分类 ) Sequence：先后次序( 视图将网络请求按访问的时间排序 ) 根据具体的需求在这两个视图之间来回切换、大多数情况下截获的请求会很多，Charles提供了一个简单Filter功能，可以输入关键字来快速筛选URL中带指定关键字的网络请求 对于具体的网络请求 若请求的内容是POST表单、Charles会自动将表单进行分项显示 若是JSON格式的内容、Charles会自动将JSON内容格式化 若是图片、Charles会显示出图片的预览 抓包工具之断点修改( 重点 ) 更改返回数据来测试临界情况：这种做法可以让一个前端开发人员独立完成测试而不用拉一个后端一起联调，并且各种特殊维度，临界点都可以独立完成。仅仅自己在青花瓷上改来改去就可以达到效果了。 在实际的工作中、你可以经常用来把某些值改为临界情况 - 以查看当前页面在处理这些临界状况收的反应、这样比(找后端联调\找临界点的测试账号)这些数据成本要低得多， 截获IPhone上的网络封包 Charles通常用来截获本地上的网络封包、当我们需要时、可以用来截取其他设备上的网络请求，如下 截取IPhone上的网络请求、首先打开Charles的代理功能Proxy -&gt; Proxy Settings填入代理端口8888 并勾选&quot;Enable transparent HTTP proxying&quot; 完成在Charles上的设置 在手机上&quot;设置&quot; -&gt; &quot;无线局域网&quot; 找到当前链接的WIFI名、点击右侧详情( 感叹号 )，在最底部找到HTTP代理、修改成手动 设置 - 无线局域网 服务器：当前Charles运行所在电脑的IP：系统偏好设置 -&gt; 网络 选中现在连着的网（大部分人应该都是WiFi吧） ​ 服务器 ： 电脑IP地址 ，端口号: 8888， 设置完成后、打开iphone上的任意与需要网络的软件、就可以在Charles上看到弹出如下信息,点击&quot;Allow&quot;即可完成设置 - 这是会有一大波抓包信息的展示 模拟慢速网络 在开发时、我们常常需要模拟慢网速或者高延迟的网络、以测试在移动网络下、开发的产品是否显示正常 在Charles菜单中，选择&quot;Proxy - Throttle Setting&quot;在之后弹出的对话框中、勾选上&quot;Enable Throttling&quot;,并且可以设置不同网速的类型如下 修改网络请求内容 有时候伪类调试服务器的接口、我们需要反复尝试不同的参数的网络请求，Charles可以很方便的提供网络请求的修改和重发功能、在网络请求上点击右键,选择&quot;Edit&quot;,即可编辑 我们可以修改请求的任何信息 URL地址 端口号 参数 等等 之后点击&quot;Execute&quot;即可发送该修改后的网络请求。Charles支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面操作iFrame的Dom]]></title>
      <url>%2F2016%2F11%2F18%2F%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9CiFrame%E7%9A%84Dom.html</url>
      <content type="text"><![CDATA[没有过时的技术只有变态的需求 contentWindow兼容主流浏览器、获取子窗口的window对象; 指定的frame或iframe所在的window对象 document对象是window对象的一个子对象; 123456789101112131415document.getElementById('iframe ID').contentWindow.document来获取iframe的document对象。相当于contentDocument属性document.getElementById('userIframe').onload = function()&#123;&#125;window.onload = function()&#123; // (LEPass &amp;&amp; LEPass.isLogin) 登录返回true、没登录放回false document.getElementById('userIframe').contentDocument.body.onclick = function(a)&#123; if(a.target.className == 'ntscshen' &amp;&amp; !(LEPass &amp;&amp; LEPass.isLogin()))&#123; // 登录内容信息 LEPass.openLoginPage(window.location.href, '', &#123; ... ... &#125;); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Atom编辑器的使用技巧]]></title>
      <url>%2F2016%2F10%2F08%2FAtom%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
      <content type="text"><![CDATA[在Atom中快速打开命令行实际开发的痛点：经常从编辑器切换到命令行( 虽然可以使用CmdTap类似的工具 )、但找到当前目录是需要花费很多时间 安装插件快速打开当前文件命令行目录 apm install open-terminal-here 打开当前项目的顶级目录alt-cmd-t 打开当前文件所在的位置ctrl-cmd-t 在Atom中新建文件、重命名、移动advanced-open-file alt-cmd-o 新建文件 shift-cmd-p rename重命名文件 ctrl-0 m 修改 a 添加文件 shift-a 添加文件夹 d 复制 自定义snippets.cson atom-ternjs Atom快捷键的使用关闭标签后 - 后悔ctrl-shift-t 样式表修改 Atom styless 树形视图的修改和浏览 cmd-\ 打开关闭树形试图( cmd-k-b ) 转移视图光标( ctrl-0 ) ctrl-[ 展开收缩 树形视图 ] ctrl-alt[ 递归展开收缩 ] J向上 k向下 展开目录 L 收起目录H 添加文件和目录 ctrl - 0 - add ( a ) 创建时候可以建立对应目录下的文件夹 ctrl-0 shift-a 创建目录 移动和重命名、复制粘贴删除 ctrl-0 move( m ) 移动到对应的文件目录下、可以用来重命名文件或者目录 duplicate( d )复制 APM 是atom package menage atom包管理工具 可以让用户在命令行下安装跟新删除编辑器的package apm search color 在命令行中显示对应的包 apm home color-picker 使用默认的浏览器打开对应包的首页 apm list包列表 Community packages 社区包 Built-in Atom packages Atom内置包 Snippets代码片段 alt+shift+s代码片段的介绍和一些简写形式 ATOM插件 - Community packages atom汉化atom-simplified-chinese-menu插件 tool bar插件 atom-ternjs JavaScript和Node自动补全插件 - 必备 highlight-selected 高亮所有和当前选中单词一样的单词，IDE标配。 autocomplete-paths 路径补全插件 linter** 和 linter-eslint** linter-eslint依赖linter，安装之后就可以按照.eslintrc文件里面配置校验JS了。 UI file-icons 高颜值的文件图标 pigments 代码颜色可视化修改颜色位置 Marker TYpe: dot indent-guide-improved 代码大括号范围提示。 minimap 类sublime的小地图功能 fold-comments 注释快速折叠 ctrl-shift-/ 快速注释会打出 顿号 elastic-tabstops 弹性制表位 highlight-selected 高亮所有和当前选中单词一样的单词 quick-highlight 高亮、同时高亮多处非选中的单词，在读代码时挺有用 highlight-line 高亮当前行 ​ IDE功能补全 emmet atom-ternjs 提供了了比较精确的代码补全功能ECMAScript、DOM/BOM、NodeJS autocomplete-paths 路径补全 advanced-open-file 翻遍的打开创建文件 cmd+alt+o autoclose-html 自动闭合标签 atom-beautify 代码美化、自己支持的语法不多、语法例如 PHP、MarkDown、Python 则需系统安装一些额外的插件 editorconfig 空格和utf-8、EditorConfig帮助开发人员保持不同的编辑器之间是一致的编码风格 Run In Browser 打开浏览器 ctrl + alt + r Bracket Matcher 括号匹配 docblockr 注释 autocomplete-emojis 表情包 Open Terminal Here 打开当前文件命令行 当前目录终端ctrl-cmd-t 项目目录终端alt-cmd-t regex-railroad-diagram package 正则 Activate Power Mode 爆炸 css-snippets javascript-snippets jQuery-snippets command palette dev live reload React hyperclick 可以跳转到变量定义的地方，也能识别import/require，点击模块名可以跳转到模块的内部。 js-hyperclick 配合 hyperclick 使用 Atom全局配置ESLinthttp://wrox.cn/article/100077190/ linter 和 linter-eslint Run in Browser ctrl + alt + R 打开浏览器 Atom Beautify ctrl + alt + B 格式化代码 ​ highlight-selected 自动补全 ​ emment autocomplete-paths 路径 扩展功能 chinese-menu 简体中文汉化 atom-beautify 格式化 Atom ternjs 代码补全 autoclose-html 自动添加结束标记 minimap 小地图 autocomplete-emojis 自动补全表情包 autocomplete-modules 自动补全模块路径 require(&#39;vue/js.js&#39;) autocomplete-paths 自动补全路径 docblockr 注释帮助包 Decorate 注释装饰 emment file-icons 文件扩展名图标和颜色以改善视觉体验 highlight-selected 高亮显示所选 quick-highlight 显示多个持久高亮 javascript-snippets js 片断 open-terminal-here 打开定位当前目录的终端 script 代码或者脚本运行 pigments css颜色 regex-railroad-diagram 正则铁路图 linter linter-eslint linter-csslint ​ ​ ​ editorconfig 编辑设置 帮助开发者在不同编辑器之间保持一致的编码风格 css和js语法检查 ​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端基础事件（一）]]></title>
      <url>%2F2016%2F09%2F22%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="text"><![CDATA[移动端事件 touchstart 手指触摸屏幕时候触发 touched 手指离开屏幕时候触发 touchmove 手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 addEventListener(‘事件名’,函数[匿名OR有名],false[冒泡和捕获]); DOM中提供的注册事件监听器的方法 它允许给一个事件注册多个监听器。不会存在前后覆盖问题 在Chrome的模拟器下可以一直识别 Event 事件对象、事件函数中默认的第一个参数 cancelBubble(取消冒泡) 阻止冒泡console.dir(event); target(标靶) 事件发生的位置console.dir(event); e.preventDefault();阻止默认事件 阻止页面中的文字选中 阻止页面上的系统菜单、滚动条失效、overflow: auto;失效 事件穿透 PC鼠标事件、但事件的执行会有300ms的延迟 点击了页面之后 - 浏览器会记录点击下去的坐标 300ms后、在该坐标找到现在在这的元素 - 执行事件 解决办法 e.preventDefault(); 阻止默认事件 不在移动端使用鼠标事件 不用a标签做页面跳转(点透问题、防止误触a标签)、把a标签的href的跳转e.preventDefault() 12345678910111213141516// 误触 document.addEventListener('touchstart', function(e) &#123; e.preventDefault(); &#125;) function mistake() &#123; this.isMove = true; &#125; var aBlock = document.querySelectorAll('a'); aBlock[0].addEventListener('touchmove', mistake, false); aBlock[0].addEventListener('touchend', function() &#123; if (!this.isMove) &#123; window.location.href = 'http://www.baidu.com'; &#125; this.isMove = false; &#125;, false);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面性能管理]]></title>
      <url>%2F2016%2F09%2F01%2F%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86.html</url>
      <content type="text"><![CDATA[网页生成的过程、大致分成五步 第一步到第三幕都非常快( 一刹那 ) “生成布局” - flow - layout(布局) - Render Tree( 渲染树 ) “绘制” - paint flow + paint = render(渲染) 重排和重绘 重绘：元素外观改变所触发的浏览器行为(visibility\outline\背景色) 重排：渲染树重新计算 “重绘”不一定”重排” “重排”必定”重绘” 从性能角度考虑 经量不把 读操作 和 写操作 在一个里面 12345// baddiv.style.left = div.offsetLeft + 10 + "px";// Goodvar left = div.offsetLeft;div.style.left = left + 10 + "px"; 一般规则如下 样式表越简单、重排和重绘就会越快 重排和重绘的DOM元素层级越高、成本就越高 table元素的重排和重绘成本、高于div元素 提高性能的技巧 读操作和写操作、应该放在一起( 不要在两个读操作之间、加入一个写操作 ) 若某个样式是通过重排得到的、把结果缓存下来、避免下一次用到的时候、浏览器重排 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 不要在JS里一条条的修改样式、要通过改变class或者csstext属性、一次性地改变样式 将元素设置display: none( 需要一次重排和重绘 )、然后对这个几点进行N+次操作、最后再回复显示( 需要一次重排和重绘 )、这样、使用两次重新渲染、取代可能的N+次的重新渲染 position属性为absolute或fixed的元素时候、重排的开销比较小、因为不用考虑它对其他元素的影响 123456// bad var top = 10; ele.style.left = left + "px"; ele.style.top = top + "px"; // Good var top = 10,left = 10; $('ele').css(&#123;left: left,top: top&#125;); css的效率 浏览器读取CSS选择器有一个很重要的原则，它们从右到左读取。这意味这像 ul &gt; li a[title=&quot;home&quot;]这样的选择器， a[title=&quot;home&quot;] 将是最先被读取的。 ID是唯一的、所以不需要任何的标签进行修饰、这样只会让效率更低ul#main{} 没有什么比用后代选择器更糟糕的做法了 后代选择器是css选择器里最昂贵的选择器 总结的优化技巧CSS优化 CSS尽量避免使用后代选择器 - 使用子代选择器代替没有比后代选择器跟糟糕的 在书写CSS时、使用类选择器”代替”元素选择器类选择器获取速度优于元素选择器 样式表越简单、嵌套层级越小( 重排和重绘就会越快 ) sass书写不大于三层 jQuery优化 选择器优化 尽可能使用ID选择器( 唯一的、最快的 )，因为jQuery源码中调用的是document.getElementById()、不要与其他选择器混搭 class选择器次之调用原生getElementByClassName()方法、指定类选择器的上下文、以缩小选择范围(默认：document)$(&#39;.class&#39;,&#39;#div1&#39;); 多级查找中、选择器的子类越详细越好$(&quot;.data li.li1&quot;) $parent.find(‘p.child’) 最快查找子元素的方法find()会调用原生的 getElementByTagName方法 经可能的缓存(缓存比不缓存快了2-3倍) 为什么要缓存得到的变量？就是减少访问DOM接口 使用链式写法、jQuery会自动缓存每一步的结果、链式比不链式写法快了25%左右 DOM优化 如果对一个DOM进行大量处理操作、使用.detach()方法、取出 - 处理 - 插入、使用.detach()方法比不使用时，快了60%。.detach(分离) .detach()移除被选元素，包括所有文本和子节点。这个方法会保留 jQuery 对象中的匹配的元素，因而可以在将来再使用这些匹配的元素。会保留所有绑定的事件、附加的数据。主要为了处理元素的大量DOM操作而生 改动DOM结构、先把它们合并，然后再一次性插入 不要使用匿名函数来用作事件处理、这样不利于调试、测试、维护和服用$(&quot;#btn&quot;).on(&#39;click&#39;,&#39;a&#39;,myClick);function myClick(){...} 在DOM元素上存储数据 123456var ele = $('#ele');ele.data(key,value);// 修改var ele = $('#ele');$.data(ele[0],key,value);// 因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用 如果可能的话使用自己的事件命名空间、这样方便地取消绑定而不影响其他的DOM元素事件绑定$(&quot;#myClick&quot;).on(&quot;click.ntscshen&quot;,&quot;a&quot;,myEventHandler);$(&quot;#myClick&quot;).off(&quot;click.ntscshen&quot;) 不要处理不存在的元素if($mySelection.length){...} 当某个事件后、如果要连续执行多个操作使用自定义事件并使用自执行事件 123456function shen()&#123; $.trigger('yang');&#125;$(document).on('yang',function()&#123; one();&#125;) 其他的优化方案 在JS内会用添加类名的方式修改”样式”属性不要使用jquery.CSS({方法})、使用添加类名的方式$(&quot;#click&quot;).addClass(&quot;error&quot;); 使用事件委托进行处理的方式就近原则 在注重性能的地方、请使用原生的Javascript代码 当需要大量的DOM操作时、先隐藏在内存中操作、在显示只触发两次重排和重绘操作 定位元素的开销较小、不用考虑对其他元素的影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BFC]]></title>
      <url>%2F2016%2F08%2F31%2FBFC.html</url>
      <content type="text"><![CDATA[BFC - 快级格式化上下文 用于决定快盒子的布局及相互影响的区域 浮动 定位absolute OR fixed 行内快级元素display: inline-block 表格单元格display: table-cell 表格标题display: table-caption 切割overflow: hidden; 弹性盒子display: flex OR display: inline-flex 快级格式化上下文对定位和清除浮动很重要 定位和清除浮动的样式规则适用于处于同一个快格式化上下文内的元素 浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只清除同一块格式化上下文中 在它前面的元素的浮动。 BFC布局规则 内部元素会在垂直方向、一个接着一个放置 每个元素的margin box的左边、与包含快border box的左边相接触即使浮动也是如此 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 具体事务 BFC的区域不会与float box重叠 计算BFC的高度时、浮动元素也参与计算 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠上下margin值穿透 自适应两列布局1234567891011121314151617181920.box &#123; position: relative; width: 500px;&#125;.aside &#123; float: left; width: 100px; height: 200px; background-color: red;&#125;.main &#123; overflow: hidden; height: 300px; background-color: pink;&#125;/*overflow: hidden;会生成浮动BFC不会与浮动元素重叠实现自适应布局*/ 清除内部浮动(overflow: hidden;)12/* 计算BFC的高度时、浮动元素也参与计算 *//* 根据这个原理、清除浮动 */ 防止垂直margin重叠(一个BFC内的上下margin会重叠)12345678910111213141516171819/* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠 */&lt;style&gt; p&#123; width: 200px; height: 200px; background-color: red; &#125; .wrap&#123; overflow: hidden; &#125;&lt;/style&gt;&lt;p&gt;111&lt;/p&gt;&lt;div class="wrap"&gt; &lt;p&gt;222&lt;/p&gt;&lt;/div&gt;/*在一个重叠的元素上包裹一层容器、并触发该容器生成一个BFC两个p标签就不属于同一个BFC、就不会发生重叠*/ BFC内部的元素和外部的元素”绝对”不会相互影响 BFC外部存在浮动时、它不应该影响BFC内部Box的布局、BFC会通过变窄、而不与浮动重叠 两列布局 BFC内部有浮动时、为了不影响外部元素的布局、BFC计算高度时会包括浮动的高度 清除浮动 BFC内部有重叠发生时、为了不影响外部元素的布局、BFC会包含margin值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css居中的几种方案]]></title>
      <url>%2F2016%2F08%2F31%2Fcss%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88.html</url>
      <content type="text"><![CDATA[固定宽高123456789.wrap &#123; width: 200px; height: 200px; background-color: red; position: absolute; left: 50%;top: 50%; margin-left: -100px; margin-top: -100px;&#125; 1234567891011.wrap &#123; width: 50%; height: 50%; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; background-color: yellow;&#125; 1234567891011.wrap &#123; width: 500px; height: 500px; background-color: chartreuse; display: table;&#125;.wrap div&#123; display: table-cell; vertical-align: middle; margin: 0 auto;&#125; 12345678910111213141516171819.box&#123; width: 500px; height: 500px; background-color: red; text-align: red;&#125;.box div&#123; /* 若为快级元素：则修改为display: inilne-block;即可 */ width: 200px; height: 200px; background-color: pink; vertical-align: middle;&#125;.box::after&#123; content:""; width: 1px; line-height: 500px; background-color: yellow;&#125; 不固定宽度123456789101112.box&#123; position: relative; width: 500px; height: 500px; background-color: red;&#125;.box .div1&#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 12345678.box&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 12345678910111213/* 相对定位 + 浮动 */.box&#123; position: relative; float: left; left: 50%; top: 50%; background-color: yellow;&#125;.box li&#123; position: relative; left: -50%; top: -50%;&#125; 123456789.box&#123; position: absolute; left: 50%; background-color: red;&#125;.box li&#123; position: relative; left: -50%;&#125; 12345678910111213141516171819202122232425262728293031.box &#123; width: 500px; height: 500px; background-color: #77BBDD; /** 各种版本兼容**/ display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; /** 垂直居中核心、兼容**/ -webkit-box-pack: center;//09版水平居中 -moz-box-pack: center; -ms-flex-pack: center;//过度版(混合版) -webkit-justify-content: center;//12版水平居中 justify-content: center; -webkit-box-align: center;//09版垂直居中 -moz-box-align: center; -ms-flex-align: center;//过度版(混合版) -webkit-align-items: center;//12版垂直居中 align-items: center; width: 0%;//低版本Android的flex-item无法等分 display: block; /* 实则只需三行 display: flex; justify-content: center; align-items: center; */&#125; 居中浮动元素1234567891011.box&#123; position: relative; left: 50%; top: 50%; float: left; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: red;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sass总结]]></title>
      <url>%2F2016%2F08%2F31%2FSass%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[变量 痛点：当配置样式时、需要重复修改各种类名的属性、这是是令人恼怒的 解决：类似于JS中的函数封装、哪里用到哪里调用、配置样式只需修改一次 变量定义在规则快之外 - 主样式内容之外 只声明变量其实没啥用处、最终的目的是达到样式可配置 凡是CSS属性的标准值存在的地方、变量都可使用 变量值也可以引用其他变量、通过颗粒度区分、为不同的值取不同的名字、这个规则相当有用 $highlight-color: #efe0ce !default;默认值 - 可配置修改、相当于jQuery的$.extend({},this.defaults,opt),this.defaults = {‘color’:’red’}, 变量名可以命名为属性名OR选择器名称、中划线和下划线可以相互混用 123456789$highlight-color: #efe0ce;$highlight-border: 1px solid $hightlight-color;.selected&#123; border: $highlight-border;&#125;// 编译.selected &#123; border: 1px solid #efe0ce;&#125; 文件导入.blue{@import &quot;blue-theme&quot;} 不能用sass的@import直接导入一个原始的css文件，因为sass会认为你想用css原生的@import。但是，因为sass的语法完全兼容css，所以你可以把原始的css文件改名为.scss后缀，即可直接导入了。 嵌套 痛点：css中重复写选择器是令人恼怒的、为了样式的不冲突需要一遍遍的写相同的ID 解决：sass的嵌套写法、只需写一遍、且可读性大大提高 在sass书写中会配到使用伪类元素情况:hover :after nth-child使用常规的嵌套方案会出现问题 正常的嵌套解耦是通过一个空格链接到子选择器的前面后代选择器 使用父选择器标示符&amp; 子组合选择器和同层组合选择器 123456789article&#123; ~ article&#123;border-top: 1px dashed #ccc;&#125; &gt; section &#123;background-color: #eee;&#125; dl &gt; &#123; dt&#123;color: #333;&#125; dd&#123;color: #555;&#125; &#125; nav + &amp; &#123;margin-top: 0;&#125;&#125; 属性嵌套 1234567891011nav &#123; border: 1px solid #ccc &#123; left: 1px; right: 1px; &#125;&#125;nav &#123; border: 1px solid #ccc; border-left: 1px; border-right: 1px;&#125; sass的条理性和可读性基础：变量、嵌套、导入、注释 混合器 痛点：整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。 通过@mixin example标示符定义、然后使用 @include example调用 大多数情况@extend可以满足日常的开发需求 而@include、较少使用的到e.g. 计算rem和px的装换 至于css3的前缀问题可以使用Autoprefixer插件在构建完成后自动添加 @include和@extend的区别 @include是用来调用@mixin的定义(包括) @extend(延伸) 继承选择器的样式 继承一个定义好的placeholder 相同之处：都可以給选择器添加一系列属性、而不用重复手写 不同之处： @extend会合并选择器、共享属性 @mixin每个选择器是独立存在的 修改伪元素 修改伪元素的content的属性值 12345678910// CSS代码.red::before &#123; content: attr(data-attr); color: red;&#125;// HTML代码&lt;div class="red" data-attr="red"&gt;内容内容内容内容&lt;/div&gt;// JacaScript代码$('.red').attr('data-attr', 'green'); 更改伪元素的样式1 12345678910111213// CSS代码.red::after&#123; content:"red", color: red;&#125;.green::after&#123; content:"green", color: green;&#125;// HTML代码&lt;div class="red"&gt;内容内容内容&lt;/div&gt;// jQuery代码$(".red").removeClass("red").addClass("green"); 更改伪元素的样式2 1234document.styleSheets[0].addRule('.red::before','color: green'); // 支持IEdocument.styleSheets[0].insertRule('.red::before &#123; color: green &#125;', 0);// 支持非IE的现代浏览器// styleSheets:返回由网页中所用到的样式表组成的数组，但是不包括直接嵌在元素里的style。 1$('&lt;style&gt;.red::before&#123;color:green&#125;&lt;/style&gt;').appendTo('head');]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>%2F2016%2F08%2F30%2F%E6%AF%8F%E6%97%A5ES6%20-%20let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[let和var的区别 块级作用域：用let定义的变量只在定义它的块中有效 不会变量提升、为声明前使用、直接报错。 let会暂时性死区、一但快内let声明了a、全局变量a将不会起作用 let不允许在相同作用域内、重复声明同一个变量 为什么引进块级作用域？for循环的i变量控制循环、防止泄露在ES6之前 - JS没有块级作用域 12345678910111213141516// function要注意的规范// 应该避免在块级作用域内声明函数、如果确实需要、也应该写成函数表达式、而不是函数式声明// 函数式声明&#123; let a = "shen"; function f()&#123; return a; &#125;&#125;// 函数表达式&#123; let a = "yang"; let b = function()&#123; return a; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>%2F2016%2F08%2F30%2Fcss%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0.html</url>
      <content type="text"><![CDATA[如何利用CSS居中一个浮动元素 居中一个浮动元素 宽度是必须的 使用相对定位 使用margin 1234567891011div&#123; position: relative;//相对于父级 left: 50%; top: 50%; float: left; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: red;&#125; 如何居中divcss中可以被继承的属性font-size、font-family、font-size、font-weight、color、text-indent、line-height、text-align、letter-spacing、word-spacing 文本相关属性 font-size、font-style、font-family、font-weight、font、 line-height、text-align、 text-indent首行文本缩进、letter-spacing单个字母间距、word-spacing以空白为分割间距 列表相关属性(li) list-style-type: decimal数字、circle空心圆、默认实心圆 list-style-position:inside放在文本以内且环绕文本 outside默认 list-style-image:使用图像来替换列表项的标记 缩写形式:list-style: decimal outside url(&#39;img/arror.gif&#39;); 颜色color 若被问到类似的问题 字体系列font-size\font-family\font-style\font-weight 字体颜色color 字体间距letter-spacing\word-spacing 列表系列list-style-image\type\position line-height\text-align\text-indent css中的选择器 常规选择器：ID\class\元素\ *通配符 伪类选择器： 动态伪类选择器:link\:visited\:active\:hover\:focus 状态伪类选择器 E:disabled{}匹配所有被禁言的表单元素 E:checked{}匹配表单中被选中的单选或复选按钮 E:enabled{}匹配被启用的元素(表单元素)checked反面 结构伪类 E:first-child选取特定元素的第一个子元素 OR last-child E:first-of-type(){} 和first-child一样、只是指定了元素类型 E:nth-child(n)选取特定元素的一个或多个子元素、n虫1开始、也可以是odd(奇数)，even(偶数)。E:nth-last-child(n) E:nth-of-type(n){}计算父元素中指定的某种类型的子元素 E:root匹配E所在文档的跟元素 E::first-line匹配元素的第一行文本、常用于文本排版 E::after E::before ::selection选中的文本背景颜色 关系选择器： A &gt; E 直系后代(children)子代选择器 A E 后代元素(find)后代选择器 E + F 同辈元素且在E后面的元素(next)相邻兄弟元素选择器 样式的优先级算法 - 优先级 内联 ID选择器 伪类选择器e.g: E:first-child{} 属性选择器e.g: input[type=&quot;text&quot;]{} 类选择器 元素选择器 通配符 !important除外]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓包工具]]></title>
      <url>%2F2016%2F08%2F22%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7.html</url>
      <content type="text"><![CDATA[抓包工具Win上的抓包 - Fiddler工具使用 Mac上的抓包 - Charles正版购买 Qi Tang’s Blog站的Charles使用心得 使用Charles、记录安装和使用 VPN 打开VPN之后、Charles将不会工作、因此撤掉VPN 设置端口并开启代理 确定工具栏下的 Proxy-&gt;Mac OS X Proxy被勾选上了 安装SSL证书 手机设置手机端和电脑链接在一个网段内，设置HTTP代理 然后打开手机浏览器，输入 http://www.charlesproxy.com/getssl/进行mac电脑charles ssl 根证书安装 安装成功之后不管是手机内部app还是浏览器浏览https 站点，都可以进行抓包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gitflow Workflow工作流]]></title>
      <url>%2F2016%2F08%2F18%2FWorkflow%E5%B7%A5%E4%BD%9C%E6%B5%81.html</url>
      <content type="text"><![CDATA[分支类型和流程 Commit message的格式 每次提交,Commit message 都包括三个部分：Header( 必须 )、Body( 可省略 )、Footer( 可省略 ) Header Header部分只有一行,包含三个字段 type( 必须 )：类型 feat：新功能( feature ) fix：修补Bug docs：文档( documentation ) style：格式( 不影响代码运行的变动 ) refactor：重构( 即不新增功能、也不是修改Bug的代码变动 ) test：增加测试 chore：构建过程或辅助工具的变动 scope( 可选 )：范围( commit影响的范围，如数据层、控制层、视图层等 ) subject( 必须 )：主题( commit目的的简短描述,不超过50个字符 ) 第一个字母小写 结尾不加句号(.) 以动词开头、使用第一人称现在时]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH Key到Github]]></title>
      <url>%2F2016%2F08%2F18%2F%E6%B7%BB%E5%8A%A0SSH%20Key%E5%88%B0Github.html</url>
      <content type="text"><![CDATA[添加ssh key到Github什么是SSH? 简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 首先先确认是否已经存在公钥了( SSH Keys ) 1ls -al ~/.ssh 若存在id_rsa或id_rsa.pub。则代表已经生成过Key值、直接将SSH key添加到Github中 生成SSH 公钥1ssh-keygen -t rsa -C "注释内容，一般为邮件地址 xxx@163.com" 接着会显示以下的输出 123456789101112131415161718192021Generating public/private rsa key pair.Enter file in which to save the key (/Users/eguchi/.ssh/id_rsa): # &lt;输入Enter键&gt;Created directory '/Users/eguchi/.ssh'.Enter passphrase (empty for no passphrase): # &lt;输入验证密码&gt;Enter same passphrase again: # &lt;再输入一次相同的验证密码&gt;Your identification has been saved in /Users/eguchi/.ssh/id_rsa.Your public key has been saved in /Users/eguchi/.ssh/id_rsa.pub.The key fingerprint is:57:15:3c:ca:f2:dc:27:6d:c2:9a:88:d0:70:cf:8d:31 xxx@163.comThe key's randomart image is:+--[ RSA 2048]----+| .o. || .o || ... . || . . E.o || +So.O o . || . ..+ + = +|| . . . o = || . . o || |+-----------------+ 默认会在相应路径下~/.ssh生成id_rsa和id_rsa.pub两个文件 复制id_rsa.pub文件信息cat ~/.ssh/id_rsa.pub。将这些信息复制到Github的Add SSH key页面。 输出实例 123456ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDkkJvxyDVh9a+zH1f7ZQq/JEI79dVjDSG4RzttQwfK+sgWEr0aAgfnxdxQeDKxIxqI1SwyTY8oCcWzvpORuPqwbc7UWWPcCvbQ3jlEdN5jvwKM82hincEWwI3wzcnVg2Mn8dH86b5m6REDzwRgozQ3lqrgwGVlTvkHDFs6H0b/1PSrMXGppOP/QXGEVhZ6Hy4m3b1wMjjrbYwmWIeYklgoGHyrldhAaDYc33y7aUcRyFyq5DubtsLn2oj4K+1q36iviCHxCOri0FDmn2dzylRCI4S+A2/P7Y7rVfdT+8OWYKCBUs8lfjujghEtejqQmj9ikyGTEAW1zQCN7hVwYdjL xxx@163.com 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下：mac 12pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard windows 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard linux 12345sudo apt-get install xclip# Downloads and installs xclip. If you don&apos;t have `apt-get`, you might need to use another installer (like `yum`)xclip -sel clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 错误处理1ssh -T git@github.com 超时报错 1ssh: connect to host github.com port 22: Operation timed out 让SSH走443端口解决方案 编辑~/.ssh/config文件(若没有、则创建一个)touch config vim config 123456789101112131415161718192021222324Host github.comUser ntscshen@163.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gi.coding.netUser ntscshen@163.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host，SSH 连接名HostName，如上所示，可以是通配符，可以是 IP，也可以是域名等User，登录的用户名IdentifyFile， version 1 协议下默认是 ~/.ssh/identify， version 2 协议下，默认是依次匹配：~/.ssh/id_dsa，~/.ssh/id_ecdsa，~/.ssh/id_rsa， 还有 version 2 兼容模式。LocalForward 端口的内部跳转Port，端口设置，默认 SSH 的端口是 22 // 公司封github 22端口Protocal，协议版本号，1 或者 2 :wq 参数说明 ssh-keygen 用于为 ssh(1)生成、管理和转换认证密钥，包括 RSA 和 DSA 两种密钥。 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。 -t type - 指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2) -C comment - 提供一个新注释 同时管理多个SSH Key 曾今只使用一个 SSH key 在github上提交代码,现在工作原因,需要再添加一个 SSH key在公司的gitlab上提交代码,配置如下 生成并添加第二个SSH Keyssh-keygen -t rsa -C &quot;注释内容，一般为邮件地址 xxx@163.com&quot; 注意此处不要一路回车,否则邮箱将覆盖上一次生成的ssh key,要给这个文件起个名字,例如 id_rsa_GitLab ,默认的是 id_rsa 1234567// 在.ssh目录下的 添加gitLab配置项# gitLabHost xxx.xxx.cnUser xxx@xxx.comHostname xxx.xxx.cnPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_GitLab 测试是否连通]]></content>
    </entry>

    
  
  
</search>
